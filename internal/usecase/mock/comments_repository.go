package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/demimurg/twitter/internal/usecase.CommentsRepository -o ./internal/usecase/mock/comments_repository.go -n CommentsRepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CommentsRepositoryMock implements usecase.CommentsRepository
type CommentsRepositoryMock struct {
	t minimock.Tester

	funcAdd          func(ctx context.Context, userID int, tweetID string, text string) (err error)
	inspectFuncAdd   func(ctx context.Context, userID int, tweetID string, text string)
	afterAddCounter  uint64
	beforeAddCounter uint64
	AddMock          mCommentsRepositoryMockAdd

	funcUpdateText          func(ctx context.Context, commentID int, newText string) (err error)
	inspectFuncUpdateText   func(ctx context.Context, commentID int, newText string)
	afterUpdateTextCounter  uint64
	beforeUpdateTextCounter uint64
	UpdateTextMock          mCommentsRepositoryMockUpdateText
}

// NewCommentsRepositoryMock returns a mock for usecase.CommentsRepository
func NewCommentsRepositoryMock(t minimock.Tester) *CommentsRepositoryMock {
	m := &CommentsRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddMock = mCommentsRepositoryMockAdd{mock: m}
	m.AddMock.callArgs = []*CommentsRepositoryMockAddParams{}

	m.UpdateTextMock = mCommentsRepositoryMockUpdateText{mock: m}
	m.UpdateTextMock.callArgs = []*CommentsRepositoryMockUpdateTextParams{}

	return m
}

type mCommentsRepositoryMockAdd struct {
	mock               *CommentsRepositoryMock
	defaultExpectation *CommentsRepositoryMockAddExpectation
	expectations       []*CommentsRepositoryMockAddExpectation

	callArgs []*CommentsRepositoryMockAddParams
	mutex    sync.RWMutex
}

// CommentsRepositoryMockAddExpectation specifies expectation struct of the CommentsRepository.Add
type CommentsRepositoryMockAddExpectation struct {
	mock    *CommentsRepositoryMock
	params  *CommentsRepositoryMockAddParams
	results *CommentsRepositoryMockAddResults
	Counter uint64
}

// CommentsRepositoryMockAddParams contains parameters of the CommentsRepository.Add
type CommentsRepositoryMockAddParams struct {
	ctx     context.Context
	userID  int
	tweetID string
	text    string
}

// CommentsRepositoryMockAddResults contains results of the CommentsRepository.Add
type CommentsRepositoryMockAddResults struct {
	err error
}

// Expect sets up expected params for CommentsRepository.Add
func (mmAdd *mCommentsRepositoryMockAdd) Expect(ctx context.Context, userID int, tweetID string, text string) *mCommentsRepositoryMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("CommentsRepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &CommentsRepositoryMockAddExpectation{}
	}

	mmAdd.defaultExpectation.params = &CommentsRepositoryMockAddParams{ctx, userID, tweetID, text}
	for _, e := range mmAdd.expectations {
		if minimock.Equal(e.params, mmAdd.defaultExpectation.params) {
			mmAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAdd.defaultExpectation.params)
		}
	}

	return mmAdd
}

// Inspect accepts an inspector function that has same arguments as the CommentsRepository.Add
func (mmAdd *mCommentsRepositoryMockAdd) Inspect(f func(ctx context.Context, userID int, tweetID string, text string)) *mCommentsRepositoryMockAdd {
	if mmAdd.mock.inspectFuncAdd != nil {
		mmAdd.mock.t.Fatalf("Inspect function is already set for CommentsRepositoryMock.Add")
	}

	mmAdd.mock.inspectFuncAdd = f

	return mmAdd
}

// Return sets up results that will be returned by CommentsRepository.Add
func (mmAdd *mCommentsRepositoryMockAdd) Return(err error) *CommentsRepositoryMock {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("CommentsRepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &CommentsRepositoryMockAddExpectation{mock: mmAdd.mock}
	}
	mmAdd.defaultExpectation.results = &CommentsRepositoryMockAddResults{err}
	return mmAdd.mock
}

// Set uses given function f to mock the CommentsRepository.Add method
func (mmAdd *mCommentsRepositoryMockAdd) Set(f func(ctx context.Context, userID int, tweetID string, text string) (err error)) *CommentsRepositoryMock {
	if mmAdd.defaultExpectation != nil {
		mmAdd.mock.t.Fatalf("Default expectation is already set for the CommentsRepository.Add method")
	}

	if len(mmAdd.expectations) > 0 {
		mmAdd.mock.t.Fatalf("Some expectations are already set for the CommentsRepository.Add method")
	}

	mmAdd.mock.funcAdd = f
	return mmAdd.mock
}

// When sets expectation for the CommentsRepository.Add which will trigger the result defined by the following
// Then helper
func (mmAdd *mCommentsRepositoryMockAdd) When(ctx context.Context, userID int, tweetID string, text string) *CommentsRepositoryMockAddExpectation {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("CommentsRepositoryMock.Add mock is already set by Set")
	}

	expectation := &CommentsRepositoryMockAddExpectation{
		mock:   mmAdd.mock,
		params: &CommentsRepositoryMockAddParams{ctx, userID, tweetID, text},
	}
	mmAdd.expectations = append(mmAdd.expectations, expectation)
	return expectation
}

// Then sets up CommentsRepository.Add return parameters for the expectation previously defined by the When method
func (e *CommentsRepositoryMockAddExpectation) Then(err error) *CommentsRepositoryMock {
	e.results = &CommentsRepositoryMockAddResults{err}
	return e.mock
}

// Add implements usecase.CommentsRepository
func (mmAdd *CommentsRepositoryMock) Add(ctx context.Context, userID int, tweetID string, text string) (err error) {
	mm_atomic.AddUint64(&mmAdd.beforeAddCounter, 1)
	defer mm_atomic.AddUint64(&mmAdd.afterAddCounter, 1)

	if mmAdd.inspectFuncAdd != nil {
		mmAdd.inspectFuncAdd(ctx, userID, tweetID, text)
	}

	mm_params := &CommentsRepositoryMockAddParams{ctx, userID, tweetID, text}

	// Record call args
	mmAdd.AddMock.mutex.Lock()
	mmAdd.AddMock.callArgs = append(mmAdd.AddMock.callArgs, mm_params)
	mmAdd.AddMock.mutex.Unlock()

	for _, e := range mmAdd.AddMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAdd.AddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAdd.AddMock.defaultExpectation.Counter, 1)
		mm_want := mmAdd.AddMock.defaultExpectation.params
		mm_got := CommentsRepositoryMockAddParams{ctx, userID, tweetID, text}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAdd.t.Errorf("CommentsRepositoryMock.Add got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAdd.AddMock.defaultExpectation.results
		if mm_results == nil {
			mmAdd.t.Fatal("No results are set for the CommentsRepositoryMock.Add")
		}
		return (*mm_results).err
	}
	if mmAdd.funcAdd != nil {
		return mmAdd.funcAdd(ctx, userID, tweetID, text)
	}
	mmAdd.t.Fatalf("Unexpected call to CommentsRepositoryMock.Add. %v %v %v %v", ctx, userID, tweetID, text)
	return
}

// AddAfterCounter returns a count of finished CommentsRepositoryMock.Add invocations
func (mmAdd *CommentsRepositoryMock) AddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.afterAddCounter)
}

// AddBeforeCounter returns a count of CommentsRepositoryMock.Add invocations
func (mmAdd *CommentsRepositoryMock) AddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.beforeAddCounter)
}

// Calls returns a list of arguments used in each call to CommentsRepositoryMock.Add.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAdd *mCommentsRepositoryMockAdd) Calls() []*CommentsRepositoryMockAddParams {
	mmAdd.mutex.RLock()

	argCopy := make([]*CommentsRepositoryMockAddParams, len(mmAdd.callArgs))
	copy(argCopy, mmAdd.callArgs)

	mmAdd.mutex.RUnlock()

	return argCopy
}

// MinimockAddDone returns true if the count of the Add invocations corresponds
// the number of defined expectations
func (m *CommentsRepositoryMock) MinimockAddDone() bool {
	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAdd != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddInspect logs each unmet expectation
func (m *CommentsRepositoryMock) MinimockAddInspect() {
	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommentsRepositoryMock.Add with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		if m.AddMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CommentsRepositoryMock.Add")
		} else {
			m.t.Errorf("Expected call to CommentsRepositoryMock.Add with params: %#v", *m.AddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAdd != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		m.t.Error("Expected call to CommentsRepositoryMock.Add")
	}
}

type mCommentsRepositoryMockUpdateText struct {
	mock               *CommentsRepositoryMock
	defaultExpectation *CommentsRepositoryMockUpdateTextExpectation
	expectations       []*CommentsRepositoryMockUpdateTextExpectation

	callArgs []*CommentsRepositoryMockUpdateTextParams
	mutex    sync.RWMutex
}

// CommentsRepositoryMockUpdateTextExpectation specifies expectation struct of the CommentsRepository.UpdateText
type CommentsRepositoryMockUpdateTextExpectation struct {
	mock    *CommentsRepositoryMock
	params  *CommentsRepositoryMockUpdateTextParams
	results *CommentsRepositoryMockUpdateTextResults
	Counter uint64
}

// CommentsRepositoryMockUpdateTextParams contains parameters of the CommentsRepository.UpdateText
type CommentsRepositoryMockUpdateTextParams struct {
	ctx       context.Context
	commentID int
	newText   string
}

// CommentsRepositoryMockUpdateTextResults contains results of the CommentsRepository.UpdateText
type CommentsRepositoryMockUpdateTextResults struct {
	err error
}

// Expect sets up expected params for CommentsRepository.UpdateText
func (mmUpdateText *mCommentsRepositoryMockUpdateText) Expect(ctx context.Context, commentID int, newText string) *mCommentsRepositoryMockUpdateText {
	if mmUpdateText.mock.funcUpdateText != nil {
		mmUpdateText.mock.t.Fatalf("CommentsRepositoryMock.UpdateText mock is already set by Set")
	}

	if mmUpdateText.defaultExpectation == nil {
		mmUpdateText.defaultExpectation = &CommentsRepositoryMockUpdateTextExpectation{}
	}

	mmUpdateText.defaultExpectation.params = &CommentsRepositoryMockUpdateTextParams{ctx, commentID, newText}
	for _, e := range mmUpdateText.expectations {
		if minimock.Equal(e.params, mmUpdateText.defaultExpectation.params) {
			mmUpdateText.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateText.defaultExpectation.params)
		}
	}

	return mmUpdateText
}

// Inspect accepts an inspector function that has same arguments as the CommentsRepository.UpdateText
func (mmUpdateText *mCommentsRepositoryMockUpdateText) Inspect(f func(ctx context.Context, commentID int, newText string)) *mCommentsRepositoryMockUpdateText {
	if mmUpdateText.mock.inspectFuncUpdateText != nil {
		mmUpdateText.mock.t.Fatalf("Inspect function is already set for CommentsRepositoryMock.UpdateText")
	}

	mmUpdateText.mock.inspectFuncUpdateText = f

	return mmUpdateText
}

// Return sets up results that will be returned by CommentsRepository.UpdateText
func (mmUpdateText *mCommentsRepositoryMockUpdateText) Return(err error) *CommentsRepositoryMock {
	if mmUpdateText.mock.funcUpdateText != nil {
		mmUpdateText.mock.t.Fatalf("CommentsRepositoryMock.UpdateText mock is already set by Set")
	}

	if mmUpdateText.defaultExpectation == nil {
		mmUpdateText.defaultExpectation = &CommentsRepositoryMockUpdateTextExpectation{mock: mmUpdateText.mock}
	}
	mmUpdateText.defaultExpectation.results = &CommentsRepositoryMockUpdateTextResults{err}
	return mmUpdateText.mock
}

// Set uses given function f to mock the CommentsRepository.UpdateText method
func (mmUpdateText *mCommentsRepositoryMockUpdateText) Set(f func(ctx context.Context, commentID int, newText string) (err error)) *CommentsRepositoryMock {
	if mmUpdateText.defaultExpectation != nil {
		mmUpdateText.mock.t.Fatalf("Default expectation is already set for the CommentsRepository.UpdateText method")
	}

	if len(mmUpdateText.expectations) > 0 {
		mmUpdateText.mock.t.Fatalf("Some expectations are already set for the CommentsRepository.UpdateText method")
	}

	mmUpdateText.mock.funcUpdateText = f
	return mmUpdateText.mock
}

// When sets expectation for the CommentsRepository.UpdateText which will trigger the result defined by the following
// Then helper
func (mmUpdateText *mCommentsRepositoryMockUpdateText) When(ctx context.Context, commentID int, newText string) *CommentsRepositoryMockUpdateTextExpectation {
	if mmUpdateText.mock.funcUpdateText != nil {
		mmUpdateText.mock.t.Fatalf("CommentsRepositoryMock.UpdateText mock is already set by Set")
	}

	expectation := &CommentsRepositoryMockUpdateTextExpectation{
		mock:   mmUpdateText.mock,
		params: &CommentsRepositoryMockUpdateTextParams{ctx, commentID, newText},
	}
	mmUpdateText.expectations = append(mmUpdateText.expectations, expectation)
	return expectation
}

// Then sets up CommentsRepository.UpdateText return parameters for the expectation previously defined by the When method
func (e *CommentsRepositoryMockUpdateTextExpectation) Then(err error) *CommentsRepositoryMock {
	e.results = &CommentsRepositoryMockUpdateTextResults{err}
	return e.mock
}

// UpdateText implements usecase.CommentsRepository
func (mmUpdateText *CommentsRepositoryMock) UpdateText(ctx context.Context, commentID int, newText string) (err error) {
	mm_atomic.AddUint64(&mmUpdateText.beforeUpdateTextCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateText.afterUpdateTextCounter, 1)

	if mmUpdateText.inspectFuncUpdateText != nil {
		mmUpdateText.inspectFuncUpdateText(ctx, commentID, newText)
	}

	mm_params := &CommentsRepositoryMockUpdateTextParams{ctx, commentID, newText}

	// Record call args
	mmUpdateText.UpdateTextMock.mutex.Lock()
	mmUpdateText.UpdateTextMock.callArgs = append(mmUpdateText.UpdateTextMock.callArgs, mm_params)
	mmUpdateText.UpdateTextMock.mutex.Unlock()

	for _, e := range mmUpdateText.UpdateTextMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateText.UpdateTextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateText.UpdateTextMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateText.UpdateTextMock.defaultExpectation.params
		mm_got := CommentsRepositoryMockUpdateTextParams{ctx, commentID, newText}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateText.t.Errorf("CommentsRepositoryMock.UpdateText got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateText.UpdateTextMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateText.t.Fatal("No results are set for the CommentsRepositoryMock.UpdateText")
		}
		return (*mm_results).err
	}
	if mmUpdateText.funcUpdateText != nil {
		return mmUpdateText.funcUpdateText(ctx, commentID, newText)
	}
	mmUpdateText.t.Fatalf("Unexpected call to CommentsRepositoryMock.UpdateText. %v %v %v", ctx, commentID, newText)
	return
}

// UpdateTextAfterCounter returns a count of finished CommentsRepositoryMock.UpdateText invocations
func (mmUpdateText *CommentsRepositoryMock) UpdateTextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateText.afterUpdateTextCounter)
}

// UpdateTextBeforeCounter returns a count of CommentsRepositoryMock.UpdateText invocations
func (mmUpdateText *CommentsRepositoryMock) UpdateTextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateText.beforeUpdateTextCounter)
}

// Calls returns a list of arguments used in each call to CommentsRepositoryMock.UpdateText.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateText *mCommentsRepositoryMockUpdateText) Calls() []*CommentsRepositoryMockUpdateTextParams {
	mmUpdateText.mutex.RLock()

	argCopy := make([]*CommentsRepositoryMockUpdateTextParams, len(mmUpdateText.callArgs))
	copy(argCopy, mmUpdateText.callArgs)

	mmUpdateText.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateTextDone returns true if the count of the UpdateText invocations corresponds
// the number of defined expectations
func (m *CommentsRepositoryMock) MinimockUpdateTextDone() bool {
	for _, e := range m.UpdateTextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateTextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateTextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateText != nil && mm_atomic.LoadUint64(&m.afterUpdateTextCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateTextInspect logs each unmet expectation
func (m *CommentsRepositoryMock) MinimockUpdateTextInspect() {
	for _, e := range m.UpdateTextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommentsRepositoryMock.UpdateText with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateTextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateTextCounter) < 1 {
		if m.UpdateTextMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CommentsRepositoryMock.UpdateText")
		} else {
			m.t.Errorf("Expected call to CommentsRepositoryMock.UpdateText with params: %#v", *m.UpdateTextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateText != nil && mm_atomic.LoadUint64(&m.afterUpdateTextCounter) < 1 {
		m.t.Error("Expected call to CommentsRepositoryMock.UpdateText")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CommentsRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddInspect()

		m.MinimockUpdateTextInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CommentsRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CommentsRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddDone() &&
		m.MinimockUpdateTextDone()
}
