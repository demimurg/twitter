package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/demimurg/twitter/internal/usecase.UserRepository -o ./internal/usecase/mock/user_repository.go -n UserRepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/demimurg/twitter/internal/entity"
	"github.com/gojuno/minimock/v3"
)

// UserRepositoryMock implements usecase.UserRepository
type UserRepositoryMock struct {
	t minimock.Tester

	funcAdd          func(ctx context.Context, name string, email string, birthDate time.Time) (i1 int, err error)
	inspectFuncAdd   func(ctx context.Context, name string, email string, birthDate time.Time)
	afterAddCounter  uint64
	beforeAddCounter uint64
	AddMock          mUserRepositoryMockAdd

	funcDelete          func(ctx context.Context, userID int) (err error)
	inspectFuncDelete   func(ctx context.Context, userID int)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mUserRepositoryMockDelete

	funcGet          func(ctx context.Context, userID int) (up1 *entity.User, err error)
	inspectFuncGet   func(ctx context.Context, userID int)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mUserRepositoryMockGet

	funcUpdateCaption          func(ctx context.Context, userID int, caption string) (err error)
	inspectFuncUpdateCaption   func(ctx context.Context, userID int, caption string)
	afterUpdateCaptionCounter  uint64
	beforeUpdateCaptionCounter uint64
	UpdateCaptionMock          mUserRepositoryMockUpdateCaption
}

// NewUserRepositoryMock returns a mock for usecase.UserRepository
func NewUserRepositoryMock(t minimock.Tester) *UserRepositoryMock {
	m := &UserRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddMock = mUserRepositoryMockAdd{mock: m}
	m.AddMock.callArgs = []*UserRepositoryMockAddParams{}

	m.DeleteMock = mUserRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*UserRepositoryMockDeleteParams{}

	m.GetMock = mUserRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*UserRepositoryMockGetParams{}

	m.UpdateCaptionMock = mUserRepositoryMockUpdateCaption{mock: m}
	m.UpdateCaptionMock.callArgs = []*UserRepositoryMockUpdateCaptionParams{}

	return m
}

type mUserRepositoryMockAdd struct {
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockAddExpectation
	expectations       []*UserRepositoryMockAddExpectation

	callArgs []*UserRepositoryMockAddParams
	mutex    sync.RWMutex
}

// UserRepositoryMockAddExpectation specifies expectation struct of the UserRepository.Add
type UserRepositoryMockAddExpectation struct {
	mock    *UserRepositoryMock
	params  *UserRepositoryMockAddParams
	results *UserRepositoryMockAddResults
	Counter uint64
}

// UserRepositoryMockAddParams contains parameters of the UserRepository.Add
type UserRepositoryMockAddParams struct {
	ctx       context.Context
	name      string
	email     string
	birthDate time.Time
}

// UserRepositoryMockAddResults contains results of the UserRepository.Add
type UserRepositoryMockAddResults struct {
	i1  int
	err error
}

// Expect sets up expected params for UserRepository.Add
func (mmAdd *mUserRepositoryMockAdd) Expect(ctx context.Context, name string, email string, birthDate time.Time) *mUserRepositoryMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("UserRepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &UserRepositoryMockAddExpectation{}
	}

	mmAdd.defaultExpectation.params = &UserRepositoryMockAddParams{ctx, name, email, birthDate}
	for _, e := range mmAdd.expectations {
		if minimock.Equal(e.params, mmAdd.defaultExpectation.params) {
			mmAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAdd.defaultExpectation.params)
		}
	}

	return mmAdd
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.Add
func (mmAdd *mUserRepositoryMockAdd) Inspect(f func(ctx context.Context, name string, email string, birthDate time.Time)) *mUserRepositoryMockAdd {
	if mmAdd.mock.inspectFuncAdd != nil {
		mmAdd.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.Add")
	}

	mmAdd.mock.inspectFuncAdd = f

	return mmAdd
}

// Return sets up results that will be returned by UserRepository.Add
func (mmAdd *mUserRepositoryMockAdd) Return(i1 int, err error) *UserRepositoryMock {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("UserRepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &UserRepositoryMockAddExpectation{mock: mmAdd.mock}
	}
	mmAdd.defaultExpectation.results = &UserRepositoryMockAddResults{i1, err}
	return mmAdd.mock
}

// Set uses given function f to mock the UserRepository.Add method
func (mmAdd *mUserRepositoryMockAdd) Set(f func(ctx context.Context, name string, email string, birthDate time.Time) (i1 int, err error)) *UserRepositoryMock {
	if mmAdd.defaultExpectation != nil {
		mmAdd.mock.t.Fatalf("Default expectation is already set for the UserRepository.Add method")
	}

	if len(mmAdd.expectations) > 0 {
		mmAdd.mock.t.Fatalf("Some expectations are already set for the UserRepository.Add method")
	}

	mmAdd.mock.funcAdd = f
	return mmAdd.mock
}

// When sets expectation for the UserRepository.Add which will trigger the result defined by the following
// Then helper
func (mmAdd *mUserRepositoryMockAdd) When(ctx context.Context, name string, email string, birthDate time.Time) *UserRepositoryMockAddExpectation {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("UserRepositoryMock.Add mock is already set by Set")
	}

	expectation := &UserRepositoryMockAddExpectation{
		mock:   mmAdd.mock,
		params: &UserRepositoryMockAddParams{ctx, name, email, birthDate},
	}
	mmAdd.expectations = append(mmAdd.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.Add return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockAddExpectation) Then(i1 int, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockAddResults{i1, err}
	return e.mock
}

// Add implements usecase.UserRepository
func (mmAdd *UserRepositoryMock) Add(ctx context.Context, name string, email string, birthDate time.Time) (i1 int, err error) {
	mm_atomic.AddUint64(&mmAdd.beforeAddCounter, 1)
	defer mm_atomic.AddUint64(&mmAdd.afterAddCounter, 1)

	if mmAdd.inspectFuncAdd != nil {
		mmAdd.inspectFuncAdd(ctx, name, email, birthDate)
	}

	mm_params := &UserRepositoryMockAddParams{ctx, name, email, birthDate}

	// Record call args
	mmAdd.AddMock.mutex.Lock()
	mmAdd.AddMock.callArgs = append(mmAdd.AddMock.callArgs, mm_params)
	mmAdd.AddMock.mutex.Unlock()

	for _, e := range mmAdd.AddMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmAdd.AddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAdd.AddMock.defaultExpectation.Counter, 1)
		mm_want := mmAdd.AddMock.defaultExpectation.params
		mm_got := UserRepositoryMockAddParams{ctx, name, email, birthDate}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAdd.t.Errorf("UserRepositoryMock.Add got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAdd.AddMock.defaultExpectation.results
		if mm_results == nil {
			mmAdd.t.Fatal("No results are set for the UserRepositoryMock.Add")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmAdd.funcAdd != nil {
		return mmAdd.funcAdd(ctx, name, email, birthDate)
	}
	mmAdd.t.Fatalf("Unexpected call to UserRepositoryMock.Add. %v %v %v %v", ctx, name, email, birthDate)
	return
}

// AddAfterCounter returns a count of finished UserRepositoryMock.Add invocations
func (mmAdd *UserRepositoryMock) AddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.afterAddCounter)
}

// AddBeforeCounter returns a count of UserRepositoryMock.Add invocations
func (mmAdd *UserRepositoryMock) AddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.beforeAddCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.Add.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAdd *mUserRepositoryMockAdd) Calls() []*UserRepositoryMockAddParams {
	mmAdd.mutex.RLock()

	argCopy := make([]*UserRepositoryMockAddParams, len(mmAdd.callArgs))
	copy(argCopy, mmAdd.callArgs)

	mmAdd.mutex.RUnlock()

	return argCopy
}

// MinimockAddDone returns true if the count of the Add invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockAddDone() bool {
	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAdd != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockAddInspect() {
	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.Add with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		if m.AddMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.Add")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.Add with params: %#v", *m.AddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAdd != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		m.t.Error("Expected call to UserRepositoryMock.Add")
	}
}

type mUserRepositoryMockDelete struct {
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockDeleteExpectation
	expectations       []*UserRepositoryMockDeleteExpectation

	callArgs []*UserRepositoryMockDeleteParams
	mutex    sync.RWMutex
}

// UserRepositoryMockDeleteExpectation specifies expectation struct of the UserRepository.Delete
type UserRepositoryMockDeleteExpectation struct {
	mock    *UserRepositoryMock
	params  *UserRepositoryMockDeleteParams
	results *UserRepositoryMockDeleteResults
	Counter uint64
}

// UserRepositoryMockDeleteParams contains parameters of the UserRepository.Delete
type UserRepositoryMockDeleteParams struct {
	ctx    context.Context
	userID int
}

// UserRepositoryMockDeleteResults contains results of the UserRepository.Delete
type UserRepositoryMockDeleteResults struct {
	err error
}

// Expect sets up expected params for UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) Expect(ctx context.Context, userID int) *mUserRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserRepositoryMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &UserRepositoryMockDeleteParams{ctx, userID}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) Inspect(f func(ctx context.Context, userID int)) *mUserRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) Return(err error) *UserRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &UserRepositoryMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the UserRepository.Delete method
func (mmDelete *mUserRepositoryMockDelete) Set(f func(ctx context.Context, userID int) (err error)) *UserRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the UserRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the UserRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the UserRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mUserRepositoryMockDelete) When(ctx context.Context, userID int) *UserRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &UserRepositoryMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &UserRepositoryMockDeleteParams{ctx, userID},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.Delete return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockDeleteExpectation) Then(err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockDeleteResults{err}
	return e.mock
}

// Delete implements usecase.UserRepository
func (mmDelete *UserRepositoryMock) Delete(ctx context.Context, userID int) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, userID)
	}

	mm_params := &UserRepositoryMockDeleteParams{ctx, userID}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := UserRepositoryMockDeleteParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("UserRepositoryMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the UserRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, userID)
	}
	mmDelete.t.Fatalf("Unexpected call to UserRepositoryMock.Delete. %v %v", ctx, userID)
	return
}

// DeleteAfterCounter returns a count of finished UserRepositoryMock.Delete invocations
func (mmDelete *UserRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of UserRepositoryMock.Delete invocations
func (mmDelete *UserRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mUserRepositoryMockDelete) Calls() []*UserRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*UserRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.Delete")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to UserRepositoryMock.Delete")
	}
}

type mUserRepositoryMockGet struct {
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockGetExpectation
	expectations       []*UserRepositoryMockGetExpectation

	callArgs []*UserRepositoryMockGetParams
	mutex    sync.RWMutex
}

// UserRepositoryMockGetExpectation specifies expectation struct of the UserRepository.Get
type UserRepositoryMockGetExpectation struct {
	mock    *UserRepositoryMock
	params  *UserRepositoryMockGetParams
	results *UserRepositoryMockGetResults
	Counter uint64
}

// UserRepositoryMockGetParams contains parameters of the UserRepository.Get
type UserRepositoryMockGetParams struct {
	ctx    context.Context
	userID int
}

// UserRepositoryMockGetResults contains results of the UserRepository.Get
type UserRepositoryMockGetResults struct {
	up1 *entity.User
	err error
}

// Expect sets up expected params for UserRepository.Get
func (mmGet *mUserRepositoryMockGet) Expect(ctx context.Context, userID int) *mUserRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserRepositoryMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &UserRepositoryMockGetParams{ctx, userID}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.Get
func (mmGet *mUserRepositoryMockGet) Inspect(f func(ctx context.Context, userID int)) *mUserRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by UserRepository.Get
func (mmGet *mUserRepositoryMockGet) Return(up1 *entity.User, err error) *UserRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &UserRepositoryMockGetResults{up1, err}
	return mmGet.mock
}

// Set uses given function f to mock the UserRepository.Get method
func (mmGet *mUserRepositoryMockGet) Set(f func(ctx context.Context, userID int) (up1 *entity.User, err error)) *UserRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the UserRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the UserRepository.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the UserRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mUserRepositoryMockGet) When(ctx context.Context, userID int) *UserRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Set")
	}

	expectation := &UserRepositoryMockGetExpectation{
		mock:   mmGet.mock,
		params: &UserRepositoryMockGetParams{ctx, userID},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.Get return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockGetExpectation) Then(up1 *entity.User, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockGetResults{up1, err}
	return e.mock
}

// Get implements usecase.UserRepository
func (mmGet *UserRepositoryMock) Get(ctx context.Context, userID int) (up1 *entity.User, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, userID)
	}

	mm_params := &UserRepositoryMockGetParams{ctx, userID}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_got := UserRepositoryMockGetParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("UserRepositoryMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the UserRepositoryMock.Get")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, userID)
	}
	mmGet.t.Fatalf("Unexpected call to UserRepositoryMock.Get. %v %v", ctx, userID)
	return
}

// GetAfterCounter returns a count of finished UserRepositoryMock.Get invocations
func (mmGet *UserRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of UserRepositoryMock.Get invocations
func (mmGet *UserRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mUserRepositoryMockGet) Calls() []*UserRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*UserRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.Get")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to UserRepositoryMock.Get")
	}
}

type mUserRepositoryMockUpdateCaption struct {
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockUpdateCaptionExpectation
	expectations       []*UserRepositoryMockUpdateCaptionExpectation

	callArgs []*UserRepositoryMockUpdateCaptionParams
	mutex    sync.RWMutex
}

// UserRepositoryMockUpdateCaptionExpectation specifies expectation struct of the UserRepository.UpdateCaption
type UserRepositoryMockUpdateCaptionExpectation struct {
	mock    *UserRepositoryMock
	params  *UserRepositoryMockUpdateCaptionParams
	results *UserRepositoryMockUpdateCaptionResults
	Counter uint64
}

// UserRepositoryMockUpdateCaptionParams contains parameters of the UserRepository.UpdateCaption
type UserRepositoryMockUpdateCaptionParams struct {
	ctx     context.Context
	userID  int
	caption string
}

// UserRepositoryMockUpdateCaptionResults contains results of the UserRepository.UpdateCaption
type UserRepositoryMockUpdateCaptionResults struct {
	err error
}

// Expect sets up expected params for UserRepository.UpdateCaption
func (mmUpdateCaption *mUserRepositoryMockUpdateCaption) Expect(ctx context.Context, userID int, caption string) *mUserRepositoryMockUpdateCaption {
	if mmUpdateCaption.mock.funcUpdateCaption != nil {
		mmUpdateCaption.mock.t.Fatalf("UserRepositoryMock.UpdateCaption mock is already set by Set")
	}

	if mmUpdateCaption.defaultExpectation == nil {
		mmUpdateCaption.defaultExpectation = &UserRepositoryMockUpdateCaptionExpectation{}
	}

	mmUpdateCaption.defaultExpectation.params = &UserRepositoryMockUpdateCaptionParams{ctx, userID, caption}
	for _, e := range mmUpdateCaption.expectations {
		if minimock.Equal(e.params, mmUpdateCaption.defaultExpectation.params) {
			mmUpdateCaption.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateCaption.defaultExpectation.params)
		}
	}

	return mmUpdateCaption
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.UpdateCaption
func (mmUpdateCaption *mUserRepositoryMockUpdateCaption) Inspect(f func(ctx context.Context, userID int, caption string)) *mUserRepositoryMockUpdateCaption {
	if mmUpdateCaption.mock.inspectFuncUpdateCaption != nil {
		mmUpdateCaption.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.UpdateCaption")
	}

	mmUpdateCaption.mock.inspectFuncUpdateCaption = f

	return mmUpdateCaption
}

// Return sets up results that will be returned by UserRepository.UpdateCaption
func (mmUpdateCaption *mUserRepositoryMockUpdateCaption) Return(err error) *UserRepositoryMock {
	if mmUpdateCaption.mock.funcUpdateCaption != nil {
		mmUpdateCaption.mock.t.Fatalf("UserRepositoryMock.UpdateCaption mock is already set by Set")
	}

	if mmUpdateCaption.defaultExpectation == nil {
		mmUpdateCaption.defaultExpectation = &UserRepositoryMockUpdateCaptionExpectation{mock: mmUpdateCaption.mock}
	}
	mmUpdateCaption.defaultExpectation.results = &UserRepositoryMockUpdateCaptionResults{err}
	return mmUpdateCaption.mock
}

// Set uses given function f to mock the UserRepository.UpdateCaption method
func (mmUpdateCaption *mUserRepositoryMockUpdateCaption) Set(f func(ctx context.Context, userID int, caption string) (err error)) *UserRepositoryMock {
	if mmUpdateCaption.defaultExpectation != nil {
		mmUpdateCaption.mock.t.Fatalf("Default expectation is already set for the UserRepository.UpdateCaption method")
	}

	if len(mmUpdateCaption.expectations) > 0 {
		mmUpdateCaption.mock.t.Fatalf("Some expectations are already set for the UserRepository.UpdateCaption method")
	}

	mmUpdateCaption.mock.funcUpdateCaption = f
	return mmUpdateCaption.mock
}

// When sets expectation for the UserRepository.UpdateCaption which will trigger the result defined by the following
// Then helper
func (mmUpdateCaption *mUserRepositoryMockUpdateCaption) When(ctx context.Context, userID int, caption string) *UserRepositoryMockUpdateCaptionExpectation {
	if mmUpdateCaption.mock.funcUpdateCaption != nil {
		mmUpdateCaption.mock.t.Fatalf("UserRepositoryMock.UpdateCaption mock is already set by Set")
	}

	expectation := &UserRepositoryMockUpdateCaptionExpectation{
		mock:   mmUpdateCaption.mock,
		params: &UserRepositoryMockUpdateCaptionParams{ctx, userID, caption},
	}
	mmUpdateCaption.expectations = append(mmUpdateCaption.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.UpdateCaption return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockUpdateCaptionExpectation) Then(err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockUpdateCaptionResults{err}
	return e.mock
}

// UpdateCaption implements usecase.UserRepository
func (mmUpdateCaption *UserRepositoryMock) UpdateCaption(ctx context.Context, userID int, caption string) (err error) {
	mm_atomic.AddUint64(&mmUpdateCaption.beforeUpdateCaptionCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateCaption.afterUpdateCaptionCounter, 1)

	if mmUpdateCaption.inspectFuncUpdateCaption != nil {
		mmUpdateCaption.inspectFuncUpdateCaption(ctx, userID, caption)
	}

	mm_params := &UserRepositoryMockUpdateCaptionParams{ctx, userID, caption}

	// Record call args
	mmUpdateCaption.UpdateCaptionMock.mutex.Lock()
	mmUpdateCaption.UpdateCaptionMock.callArgs = append(mmUpdateCaption.UpdateCaptionMock.callArgs, mm_params)
	mmUpdateCaption.UpdateCaptionMock.mutex.Unlock()

	for _, e := range mmUpdateCaption.UpdateCaptionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateCaption.UpdateCaptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateCaption.UpdateCaptionMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateCaption.UpdateCaptionMock.defaultExpectation.params
		mm_got := UserRepositoryMockUpdateCaptionParams{ctx, userID, caption}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateCaption.t.Errorf("UserRepositoryMock.UpdateCaption got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateCaption.UpdateCaptionMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateCaption.t.Fatal("No results are set for the UserRepositoryMock.UpdateCaption")
		}
		return (*mm_results).err
	}
	if mmUpdateCaption.funcUpdateCaption != nil {
		return mmUpdateCaption.funcUpdateCaption(ctx, userID, caption)
	}
	mmUpdateCaption.t.Fatalf("Unexpected call to UserRepositoryMock.UpdateCaption. %v %v %v", ctx, userID, caption)
	return
}

// UpdateCaptionAfterCounter returns a count of finished UserRepositoryMock.UpdateCaption invocations
func (mmUpdateCaption *UserRepositoryMock) UpdateCaptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCaption.afterUpdateCaptionCounter)
}

// UpdateCaptionBeforeCounter returns a count of UserRepositoryMock.UpdateCaption invocations
func (mmUpdateCaption *UserRepositoryMock) UpdateCaptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCaption.beforeUpdateCaptionCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.UpdateCaption.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateCaption *mUserRepositoryMockUpdateCaption) Calls() []*UserRepositoryMockUpdateCaptionParams {
	mmUpdateCaption.mutex.RLock()

	argCopy := make([]*UserRepositoryMockUpdateCaptionParams, len(mmUpdateCaption.callArgs))
	copy(argCopy, mmUpdateCaption.callArgs)

	mmUpdateCaption.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateCaptionDone returns true if the count of the UpdateCaption invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockUpdateCaptionDone() bool {
	for _, e := range m.UpdateCaptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCaptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCaptionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCaption != nil && mm_atomic.LoadUint64(&m.afterUpdateCaptionCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateCaptionInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockUpdateCaptionInspect() {
	for _, e := range m.UpdateCaptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.UpdateCaption with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCaptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCaptionCounter) < 1 {
		if m.UpdateCaptionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.UpdateCaption")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.UpdateCaption with params: %#v", *m.UpdateCaptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCaption != nil && mm_atomic.LoadUint64(&m.afterUpdateCaptionCounter) < 1 {
		m.t.Error("Expected call to UserRepositoryMock.UpdateCaption")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddInspect()

		m.MinimockDeleteInspect()

		m.MinimockGetInspect()

		m.MinimockUpdateCaptionInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockUpdateCaptionDone()
}
