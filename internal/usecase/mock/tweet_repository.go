package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/demimurg/twitter/internal/usecase.TweetRepository -o ./internal/usecase/mock/tweet_repository.go -n TweetRepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/demimurg/twitter/internal/entity"
	"github.com/gojuno/minimock/v3"
)

// TweetRepositoryMock implements usecase.TweetRepository
type TweetRepositoryMock struct {
	t minimock.Tester

	funcAdd          func(ctx context.Context, userID int, tweetText string) (err error)
	inspectFuncAdd   func(ctx context.Context, userID int, tweetText string)
	afterAddCounter  uint64
	beforeAddCounter uint64
	AddMock          mTweetRepositoryMockAdd

	funcAddComment          func(ctx context.Context, userID int, tweetID int, commentText string) (err error)
	inspectFuncAddComment   func(ctx context.Context, userID int, tweetID int, commentText string)
	afterAddCommentCounter  uint64
	beforeAddCommentCounter uint64
	AddCommentMock          mTweetRepositoryMockAddComment

	funcGetLatest          func(ctx context.Context, userID int, limit int) (ta1 []entity.Tweet, err error)
	inspectFuncGetLatest   func(ctx context.Context, userID int, limit int)
	afterGetLatestCounter  uint64
	beforeGetLatestCounter uint64
	GetLatestMock          mTweetRepositoryMockGetLatest

	funcUpdate          func(ctx context.Context, tweetID int, newText string) (err error)
	inspectFuncUpdate   func(ctx context.Context, tweetID int, newText string)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mTweetRepositoryMockUpdate

	funcUpdateComment          func(ctx context.Context, commentID int, newText string) (err error)
	inspectFuncUpdateComment   func(ctx context.Context, commentID int, newText string)
	afterUpdateCommentCounter  uint64
	beforeUpdateCommentCounter uint64
	UpdateCommentMock          mTweetRepositoryMockUpdateComment
}

// NewTweetRepositoryMock returns a mock for usecase.TweetRepository
func NewTweetRepositoryMock(t minimock.Tester) *TweetRepositoryMock {
	m := &TweetRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddMock = mTweetRepositoryMockAdd{mock: m}
	m.AddMock.callArgs = []*TweetRepositoryMockAddParams{}

	m.AddCommentMock = mTweetRepositoryMockAddComment{mock: m}
	m.AddCommentMock.callArgs = []*TweetRepositoryMockAddCommentParams{}

	m.GetLatestMock = mTweetRepositoryMockGetLatest{mock: m}
	m.GetLatestMock.callArgs = []*TweetRepositoryMockGetLatestParams{}

	m.UpdateMock = mTweetRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*TweetRepositoryMockUpdateParams{}

	m.UpdateCommentMock = mTweetRepositoryMockUpdateComment{mock: m}
	m.UpdateCommentMock.callArgs = []*TweetRepositoryMockUpdateCommentParams{}

	return m
}

type mTweetRepositoryMockAdd struct {
	mock               *TweetRepositoryMock
	defaultExpectation *TweetRepositoryMockAddExpectation
	expectations       []*TweetRepositoryMockAddExpectation

	callArgs []*TweetRepositoryMockAddParams
	mutex    sync.RWMutex
}

// TweetRepositoryMockAddExpectation specifies expectation struct of the TweetRepository.Add
type TweetRepositoryMockAddExpectation struct {
	mock    *TweetRepositoryMock
	params  *TweetRepositoryMockAddParams
	results *TweetRepositoryMockAddResults
	Counter uint64
}

// TweetRepositoryMockAddParams contains parameters of the TweetRepository.Add
type TweetRepositoryMockAddParams struct {
	ctx       context.Context
	userID    int
	tweetText string
}

// TweetRepositoryMockAddResults contains results of the TweetRepository.Add
type TweetRepositoryMockAddResults struct {
	err error
}

// Expect sets up expected params for TweetRepository.Add
func (mmAdd *mTweetRepositoryMockAdd) Expect(ctx context.Context, userID int, tweetText string) *mTweetRepositoryMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("TweetRepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &TweetRepositoryMockAddExpectation{}
	}

	mmAdd.defaultExpectation.params = &TweetRepositoryMockAddParams{ctx, userID, tweetText}
	for _, e := range mmAdd.expectations {
		if minimock.Equal(e.params, mmAdd.defaultExpectation.params) {
			mmAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAdd.defaultExpectation.params)
		}
	}

	return mmAdd
}

// Inspect accepts an inspector function that has same arguments as the TweetRepository.Add
func (mmAdd *mTweetRepositoryMockAdd) Inspect(f func(ctx context.Context, userID int, tweetText string)) *mTweetRepositoryMockAdd {
	if mmAdd.mock.inspectFuncAdd != nil {
		mmAdd.mock.t.Fatalf("Inspect function is already set for TweetRepositoryMock.Add")
	}

	mmAdd.mock.inspectFuncAdd = f

	return mmAdd
}

// Return sets up results that will be returned by TweetRepository.Add
func (mmAdd *mTweetRepositoryMockAdd) Return(err error) *TweetRepositoryMock {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("TweetRepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &TweetRepositoryMockAddExpectation{mock: mmAdd.mock}
	}
	mmAdd.defaultExpectation.results = &TweetRepositoryMockAddResults{err}
	return mmAdd.mock
}

// Set uses given function f to mock the TweetRepository.Add method
func (mmAdd *mTweetRepositoryMockAdd) Set(f func(ctx context.Context, userID int, tweetText string) (err error)) *TweetRepositoryMock {
	if mmAdd.defaultExpectation != nil {
		mmAdd.mock.t.Fatalf("Default expectation is already set for the TweetRepository.Add method")
	}

	if len(mmAdd.expectations) > 0 {
		mmAdd.mock.t.Fatalf("Some expectations are already set for the TweetRepository.Add method")
	}

	mmAdd.mock.funcAdd = f
	return mmAdd.mock
}

// When sets expectation for the TweetRepository.Add which will trigger the result defined by the following
// Then helper
func (mmAdd *mTweetRepositoryMockAdd) When(ctx context.Context, userID int, tweetText string) *TweetRepositoryMockAddExpectation {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("TweetRepositoryMock.Add mock is already set by Set")
	}

	expectation := &TweetRepositoryMockAddExpectation{
		mock:   mmAdd.mock,
		params: &TweetRepositoryMockAddParams{ctx, userID, tweetText},
	}
	mmAdd.expectations = append(mmAdd.expectations, expectation)
	return expectation
}

// Then sets up TweetRepository.Add return parameters for the expectation previously defined by the When method
func (e *TweetRepositoryMockAddExpectation) Then(err error) *TweetRepositoryMock {
	e.results = &TweetRepositoryMockAddResults{err}
	return e.mock
}

// Add implements usecase.TweetRepository
func (mmAdd *TweetRepositoryMock) Add(ctx context.Context, userID int, tweetText string) (err error) {
	mm_atomic.AddUint64(&mmAdd.beforeAddCounter, 1)
	defer mm_atomic.AddUint64(&mmAdd.afterAddCounter, 1)

	if mmAdd.inspectFuncAdd != nil {
		mmAdd.inspectFuncAdd(ctx, userID, tweetText)
	}

	mm_params := &TweetRepositoryMockAddParams{ctx, userID, tweetText}

	// Record call args
	mmAdd.AddMock.mutex.Lock()
	mmAdd.AddMock.callArgs = append(mmAdd.AddMock.callArgs, mm_params)
	mmAdd.AddMock.mutex.Unlock()

	for _, e := range mmAdd.AddMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAdd.AddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAdd.AddMock.defaultExpectation.Counter, 1)
		mm_want := mmAdd.AddMock.defaultExpectation.params
		mm_got := TweetRepositoryMockAddParams{ctx, userID, tweetText}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAdd.t.Errorf("TweetRepositoryMock.Add got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAdd.AddMock.defaultExpectation.results
		if mm_results == nil {
			mmAdd.t.Fatal("No results are set for the TweetRepositoryMock.Add")
		}
		return (*mm_results).err
	}
	if mmAdd.funcAdd != nil {
		return mmAdd.funcAdd(ctx, userID, tweetText)
	}
	mmAdd.t.Fatalf("Unexpected call to TweetRepositoryMock.Add. %v %v %v", ctx, userID, tweetText)
	return
}

// AddAfterCounter returns a count of finished TweetRepositoryMock.Add invocations
func (mmAdd *TweetRepositoryMock) AddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.afterAddCounter)
}

// AddBeforeCounter returns a count of TweetRepositoryMock.Add invocations
func (mmAdd *TweetRepositoryMock) AddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.beforeAddCounter)
}

// Calls returns a list of arguments used in each call to TweetRepositoryMock.Add.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAdd *mTweetRepositoryMockAdd) Calls() []*TweetRepositoryMockAddParams {
	mmAdd.mutex.RLock()

	argCopy := make([]*TweetRepositoryMockAddParams, len(mmAdd.callArgs))
	copy(argCopy, mmAdd.callArgs)

	mmAdd.mutex.RUnlock()

	return argCopy
}

// MinimockAddDone returns true if the count of the Add invocations corresponds
// the number of defined expectations
func (m *TweetRepositoryMock) MinimockAddDone() bool {
	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAdd != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddInspect logs each unmet expectation
func (m *TweetRepositoryMock) MinimockAddInspect() {
	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TweetRepositoryMock.Add with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		if m.AddMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TweetRepositoryMock.Add")
		} else {
			m.t.Errorf("Expected call to TweetRepositoryMock.Add with params: %#v", *m.AddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAdd != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		m.t.Error("Expected call to TweetRepositoryMock.Add")
	}
}

type mTweetRepositoryMockAddComment struct {
	mock               *TweetRepositoryMock
	defaultExpectation *TweetRepositoryMockAddCommentExpectation
	expectations       []*TweetRepositoryMockAddCommentExpectation

	callArgs []*TweetRepositoryMockAddCommentParams
	mutex    sync.RWMutex
}

// TweetRepositoryMockAddCommentExpectation specifies expectation struct of the TweetRepository.AddComment
type TweetRepositoryMockAddCommentExpectation struct {
	mock    *TweetRepositoryMock
	params  *TweetRepositoryMockAddCommentParams
	results *TweetRepositoryMockAddCommentResults
	Counter uint64
}

// TweetRepositoryMockAddCommentParams contains parameters of the TweetRepository.AddComment
type TweetRepositoryMockAddCommentParams struct {
	ctx         context.Context
	userID      int
	tweetID     int
	commentText string
}

// TweetRepositoryMockAddCommentResults contains results of the TweetRepository.AddComment
type TweetRepositoryMockAddCommentResults struct {
	err error
}

// Expect sets up expected params for TweetRepository.AddComment
func (mmAddComment *mTweetRepositoryMockAddComment) Expect(ctx context.Context, userID int, tweetID int, commentText string) *mTweetRepositoryMockAddComment {
	if mmAddComment.mock.funcAddComment != nil {
		mmAddComment.mock.t.Fatalf("TweetRepositoryMock.AddComment mock is already set by Set")
	}

	if mmAddComment.defaultExpectation == nil {
		mmAddComment.defaultExpectation = &TweetRepositoryMockAddCommentExpectation{}
	}

	mmAddComment.defaultExpectation.params = &TweetRepositoryMockAddCommentParams{ctx, userID, tweetID, commentText}
	for _, e := range mmAddComment.expectations {
		if minimock.Equal(e.params, mmAddComment.defaultExpectation.params) {
			mmAddComment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddComment.defaultExpectation.params)
		}
	}

	return mmAddComment
}

// Inspect accepts an inspector function that has same arguments as the TweetRepository.AddComment
func (mmAddComment *mTweetRepositoryMockAddComment) Inspect(f func(ctx context.Context, userID int, tweetID int, commentText string)) *mTweetRepositoryMockAddComment {
	if mmAddComment.mock.inspectFuncAddComment != nil {
		mmAddComment.mock.t.Fatalf("Inspect function is already set for TweetRepositoryMock.AddComment")
	}

	mmAddComment.mock.inspectFuncAddComment = f

	return mmAddComment
}

// Return sets up results that will be returned by TweetRepository.AddComment
func (mmAddComment *mTweetRepositoryMockAddComment) Return(err error) *TweetRepositoryMock {
	if mmAddComment.mock.funcAddComment != nil {
		mmAddComment.mock.t.Fatalf("TweetRepositoryMock.AddComment mock is already set by Set")
	}

	if mmAddComment.defaultExpectation == nil {
		mmAddComment.defaultExpectation = &TweetRepositoryMockAddCommentExpectation{mock: mmAddComment.mock}
	}
	mmAddComment.defaultExpectation.results = &TweetRepositoryMockAddCommentResults{err}
	return mmAddComment.mock
}

// Set uses given function f to mock the TweetRepository.AddComment method
func (mmAddComment *mTweetRepositoryMockAddComment) Set(f func(ctx context.Context, userID int, tweetID int, commentText string) (err error)) *TweetRepositoryMock {
	if mmAddComment.defaultExpectation != nil {
		mmAddComment.mock.t.Fatalf("Default expectation is already set for the TweetRepository.AddComment method")
	}

	if len(mmAddComment.expectations) > 0 {
		mmAddComment.mock.t.Fatalf("Some expectations are already set for the TweetRepository.AddComment method")
	}

	mmAddComment.mock.funcAddComment = f
	return mmAddComment.mock
}

// When sets expectation for the TweetRepository.AddComment which will trigger the result defined by the following
// Then helper
func (mmAddComment *mTweetRepositoryMockAddComment) When(ctx context.Context, userID int, tweetID int, commentText string) *TweetRepositoryMockAddCommentExpectation {
	if mmAddComment.mock.funcAddComment != nil {
		mmAddComment.mock.t.Fatalf("TweetRepositoryMock.AddComment mock is already set by Set")
	}

	expectation := &TweetRepositoryMockAddCommentExpectation{
		mock:   mmAddComment.mock,
		params: &TweetRepositoryMockAddCommentParams{ctx, userID, tweetID, commentText},
	}
	mmAddComment.expectations = append(mmAddComment.expectations, expectation)
	return expectation
}

// Then sets up TweetRepository.AddComment return parameters for the expectation previously defined by the When method
func (e *TweetRepositoryMockAddCommentExpectation) Then(err error) *TweetRepositoryMock {
	e.results = &TweetRepositoryMockAddCommentResults{err}
	return e.mock
}

// AddComment implements usecase.TweetRepository
func (mmAddComment *TweetRepositoryMock) AddComment(ctx context.Context, userID int, tweetID int, commentText string) (err error) {
	mm_atomic.AddUint64(&mmAddComment.beforeAddCommentCounter, 1)
	defer mm_atomic.AddUint64(&mmAddComment.afterAddCommentCounter, 1)

	if mmAddComment.inspectFuncAddComment != nil {
		mmAddComment.inspectFuncAddComment(ctx, userID, tweetID, commentText)
	}

	mm_params := &TweetRepositoryMockAddCommentParams{ctx, userID, tweetID, commentText}

	// Record call args
	mmAddComment.AddCommentMock.mutex.Lock()
	mmAddComment.AddCommentMock.callArgs = append(mmAddComment.AddCommentMock.callArgs, mm_params)
	mmAddComment.AddCommentMock.mutex.Unlock()

	for _, e := range mmAddComment.AddCommentMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddComment.AddCommentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddComment.AddCommentMock.defaultExpectation.Counter, 1)
		mm_want := mmAddComment.AddCommentMock.defaultExpectation.params
		mm_got := TweetRepositoryMockAddCommentParams{ctx, userID, tweetID, commentText}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddComment.t.Errorf("TweetRepositoryMock.AddComment got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddComment.AddCommentMock.defaultExpectation.results
		if mm_results == nil {
			mmAddComment.t.Fatal("No results are set for the TweetRepositoryMock.AddComment")
		}
		return (*mm_results).err
	}
	if mmAddComment.funcAddComment != nil {
		return mmAddComment.funcAddComment(ctx, userID, tweetID, commentText)
	}
	mmAddComment.t.Fatalf("Unexpected call to TweetRepositoryMock.AddComment. %v %v %v %v", ctx, userID, tweetID, commentText)
	return
}

// AddCommentAfterCounter returns a count of finished TweetRepositoryMock.AddComment invocations
func (mmAddComment *TweetRepositoryMock) AddCommentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddComment.afterAddCommentCounter)
}

// AddCommentBeforeCounter returns a count of TweetRepositoryMock.AddComment invocations
func (mmAddComment *TweetRepositoryMock) AddCommentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddComment.beforeAddCommentCounter)
}

// Calls returns a list of arguments used in each call to TweetRepositoryMock.AddComment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddComment *mTweetRepositoryMockAddComment) Calls() []*TweetRepositoryMockAddCommentParams {
	mmAddComment.mutex.RLock()

	argCopy := make([]*TweetRepositoryMockAddCommentParams, len(mmAddComment.callArgs))
	copy(argCopy, mmAddComment.callArgs)

	mmAddComment.mutex.RUnlock()

	return argCopy
}

// MinimockAddCommentDone returns true if the count of the AddComment invocations corresponds
// the number of defined expectations
func (m *TweetRepositoryMock) MinimockAddCommentDone() bool {
	for _, e := range m.AddCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddCommentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddCommentCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddComment != nil && mm_atomic.LoadUint64(&m.afterAddCommentCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddCommentInspect logs each unmet expectation
func (m *TweetRepositoryMock) MinimockAddCommentInspect() {
	for _, e := range m.AddCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TweetRepositoryMock.AddComment with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddCommentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddCommentCounter) < 1 {
		if m.AddCommentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TweetRepositoryMock.AddComment")
		} else {
			m.t.Errorf("Expected call to TweetRepositoryMock.AddComment with params: %#v", *m.AddCommentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddComment != nil && mm_atomic.LoadUint64(&m.afterAddCommentCounter) < 1 {
		m.t.Error("Expected call to TweetRepositoryMock.AddComment")
	}
}

type mTweetRepositoryMockGetLatest struct {
	mock               *TweetRepositoryMock
	defaultExpectation *TweetRepositoryMockGetLatestExpectation
	expectations       []*TweetRepositoryMockGetLatestExpectation

	callArgs []*TweetRepositoryMockGetLatestParams
	mutex    sync.RWMutex
}

// TweetRepositoryMockGetLatestExpectation specifies expectation struct of the TweetRepository.GetLatest
type TweetRepositoryMockGetLatestExpectation struct {
	mock    *TweetRepositoryMock
	params  *TweetRepositoryMockGetLatestParams
	results *TweetRepositoryMockGetLatestResults
	Counter uint64
}

// TweetRepositoryMockGetLatestParams contains parameters of the TweetRepository.GetLatest
type TweetRepositoryMockGetLatestParams struct {
	ctx    context.Context
	userID int
	limit  int
}

// TweetRepositoryMockGetLatestResults contains results of the TweetRepository.GetLatest
type TweetRepositoryMockGetLatestResults struct {
	ta1 []entity.Tweet
	err error
}

// Expect sets up expected params for TweetRepository.GetLatest
func (mmGetLatest *mTweetRepositoryMockGetLatest) Expect(ctx context.Context, userID int, limit int) *mTweetRepositoryMockGetLatest {
	if mmGetLatest.mock.funcGetLatest != nil {
		mmGetLatest.mock.t.Fatalf("TweetRepositoryMock.GetLatest mock is already set by Set")
	}

	if mmGetLatest.defaultExpectation == nil {
		mmGetLatest.defaultExpectation = &TweetRepositoryMockGetLatestExpectation{}
	}

	mmGetLatest.defaultExpectation.params = &TweetRepositoryMockGetLatestParams{ctx, userID, limit}
	for _, e := range mmGetLatest.expectations {
		if minimock.Equal(e.params, mmGetLatest.defaultExpectation.params) {
			mmGetLatest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetLatest.defaultExpectation.params)
		}
	}

	return mmGetLatest
}

// Inspect accepts an inspector function that has same arguments as the TweetRepository.GetLatest
func (mmGetLatest *mTweetRepositoryMockGetLatest) Inspect(f func(ctx context.Context, userID int, limit int)) *mTweetRepositoryMockGetLatest {
	if mmGetLatest.mock.inspectFuncGetLatest != nil {
		mmGetLatest.mock.t.Fatalf("Inspect function is already set for TweetRepositoryMock.GetLatest")
	}

	mmGetLatest.mock.inspectFuncGetLatest = f

	return mmGetLatest
}

// Return sets up results that will be returned by TweetRepository.GetLatest
func (mmGetLatest *mTweetRepositoryMockGetLatest) Return(ta1 []entity.Tweet, err error) *TweetRepositoryMock {
	if mmGetLatest.mock.funcGetLatest != nil {
		mmGetLatest.mock.t.Fatalf("TweetRepositoryMock.GetLatest mock is already set by Set")
	}

	if mmGetLatest.defaultExpectation == nil {
		mmGetLatest.defaultExpectation = &TweetRepositoryMockGetLatestExpectation{mock: mmGetLatest.mock}
	}
	mmGetLatest.defaultExpectation.results = &TweetRepositoryMockGetLatestResults{ta1, err}
	return mmGetLatest.mock
}

// Set uses given function f to mock the TweetRepository.GetLatest method
func (mmGetLatest *mTweetRepositoryMockGetLatest) Set(f func(ctx context.Context, userID int, limit int) (ta1 []entity.Tweet, err error)) *TweetRepositoryMock {
	if mmGetLatest.defaultExpectation != nil {
		mmGetLatest.mock.t.Fatalf("Default expectation is already set for the TweetRepository.GetLatest method")
	}

	if len(mmGetLatest.expectations) > 0 {
		mmGetLatest.mock.t.Fatalf("Some expectations are already set for the TweetRepository.GetLatest method")
	}

	mmGetLatest.mock.funcGetLatest = f
	return mmGetLatest.mock
}

// When sets expectation for the TweetRepository.GetLatest which will trigger the result defined by the following
// Then helper
func (mmGetLatest *mTweetRepositoryMockGetLatest) When(ctx context.Context, userID int, limit int) *TweetRepositoryMockGetLatestExpectation {
	if mmGetLatest.mock.funcGetLatest != nil {
		mmGetLatest.mock.t.Fatalf("TweetRepositoryMock.GetLatest mock is already set by Set")
	}

	expectation := &TweetRepositoryMockGetLatestExpectation{
		mock:   mmGetLatest.mock,
		params: &TweetRepositoryMockGetLatestParams{ctx, userID, limit},
	}
	mmGetLatest.expectations = append(mmGetLatest.expectations, expectation)
	return expectation
}

// Then sets up TweetRepository.GetLatest return parameters for the expectation previously defined by the When method
func (e *TweetRepositoryMockGetLatestExpectation) Then(ta1 []entity.Tweet, err error) *TweetRepositoryMock {
	e.results = &TweetRepositoryMockGetLatestResults{ta1, err}
	return e.mock
}

// GetLatest implements usecase.TweetRepository
func (mmGetLatest *TweetRepositoryMock) GetLatest(ctx context.Context, userID int, limit int) (ta1 []entity.Tweet, err error) {
	mm_atomic.AddUint64(&mmGetLatest.beforeGetLatestCounter, 1)
	defer mm_atomic.AddUint64(&mmGetLatest.afterGetLatestCounter, 1)

	if mmGetLatest.inspectFuncGetLatest != nil {
		mmGetLatest.inspectFuncGetLatest(ctx, userID, limit)
	}

	mm_params := &TweetRepositoryMockGetLatestParams{ctx, userID, limit}

	// Record call args
	mmGetLatest.GetLatestMock.mutex.Lock()
	mmGetLatest.GetLatestMock.callArgs = append(mmGetLatest.GetLatestMock.callArgs, mm_params)
	mmGetLatest.GetLatestMock.mutex.Unlock()

	for _, e := range mmGetLatest.GetLatestMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ta1, e.results.err
		}
	}

	if mmGetLatest.GetLatestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetLatest.GetLatestMock.defaultExpectation.Counter, 1)
		mm_want := mmGetLatest.GetLatestMock.defaultExpectation.params
		mm_got := TweetRepositoryMockGetLatestParams{ctx, userID, limit}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetLatest.t.Errorf("TweetRepositoryMock.GetLatest got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetLatest.GetLatestMock.defaultExpectation.results
		if mm_results == nil {
			mmGetLatest.t.Fatal("No results are set for the TweetRepositoryMock.GetLatest")
		}
		return (*mm_results).ta1, (*mm_results).err
	}
	if mmGetLatest.funcGetLatest != nil {
		return mmGetLatest.funcGetLatest(ctx, userID, limit)
	}
	mmGetLatest.t.Fatalf("Unexpected call to TweetRepositoryMock.GetLatest. %v %v %v", ctx, userID, limit)
	return
}

// GetLatestAfterCounter returns a count of finished TweetRepositoryMock.GetLatest invocations
func (mmGetLatest *TweetRepositoryMock) GetLatestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLatest.afterGetLatestCounter)
}

// GetLatestBeforeCounter returns a count of TweetRepositoryMock.GetLatest invocations
func (mmGetLatest *TweetRepositoryMock) GetLatestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLatest.beforeGetLatestCounter)
}

// Calls returns a list of arguments used in each call to TweetRepositoryMock.GetLatest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetLatest *mTweetRepositoryMockGetLatest) Calls() []*TweetRepositoryMockGetLatestParams {
	mmGetLatest.mutex.RLock()

	argCopy := make([]*TweetRepositoryMockGetLatestParams, len(mmGetLatest.callArgs))
	copy(argCopy, mmGetLatest.callArgs)

	mmGetLatest.mutex.RUnlock()

	return argCopy
}

// MinimockGetLatestDone returns true if the count of the GetLatest invocations corresponds
// the number of defined expectations
func (m *TweetRepositoryMock) MinimockGetLatestDone() bool {
	for _, e := range m.GetLatestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetLatestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetLatestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetLatest != nil && mm_atomic.LoadUint64(&m.afterGetLatestCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetLatestInspect logs each unmet expectation
func (m *TweetRepositoryMock) MinimockGetLatestInspect() {
	for _, e := range m.GetLatestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TweetRepositoryMock.GetLatest with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetLatestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetLatestCounter) < 1 {
		if m.GetLatestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TweetRepositoryMock.GetLatest")
		} else {
			m.t.Errorf("Expected call to TweetRepositoryMock.GetLatest with params: %#v", *m.GetLatestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetLatest != nil && mm_atomic.LoadUint64(&m.afterGetLatestCounter) < 1 {
		m.t.Error("Expected call to TweetRepositoryMock.GetLatest")
	}
}

type mTweetRepositoryMockUpdate struct {
	mock               *TweetRepositoryMock
	defaultExpectation *TweetRepositoryMockUpdateExpectation
	expectations       []*TweetRepositoryMockUpdateExpectation

	callArgs []*TweetRepositoryMockUpdateParams
	mutex    sync.RWMutex
}

// TweetRepositoryMockUpdateExpectation specifies expectation struct of the TweetRepository.Update
type TweetRepositoryMockUpdateExpectation struct {
	mock    *TweetRepositoryMock
	params  *TweetRepositoryMockUpdateParams
	results *TweetRepositoryMockUpdateResults
	Counter uint64
}

// TweetRepositoryMockUpdateParams contains parameters of the TweetRepository.Update
type TweetRepositoryMockUpdateParams struct {
	ctx     context.Context
	tweetID int
	newText string
}

// TweetRepositoryMockUpdateResults contains results of the TweetRepository.Update
type TweetRepositoryMockUpdateResults struct {
	err error
}

// Expect sets up expected params for TweetRepository.Update
func (mmUpdate *mTweetRepositoryMockUpdate) Expect(ctx context.Context, tweetID int, newText string) *mTweetRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("TweetRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &TweetRepositoryMockUpdateExpectation{}
	}

	mmUpdate.defaultExpectation.params = &TweetRepositoryMockUpdateParams{ctx, tweetID, newText}
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the TweetRepository.Update
func (mmUpdate *mTweetRepositoryMockUpdate) Inspect(f func(ctx context.Context, tweetID int, newText string)) *mTweetRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for TweetRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by TweetRepository.Update
func (mmUpdate *mTweetRepositoryMockUpdate) Return(err error) *TweetRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("TweetRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &TweetRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &TweetRepositoryMockUpdateResults{err}
	return mmUpdate.mock
}

// Set uses given function f to mock the TweetRepository.Update method
func (mmUpdate *mTweetRepositoryMockUpdate) Set(f func(ctx context.Context, tweetID int, newText string) (err error)) *TweetRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the TweetRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the TweetRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	return mmUpdate.mock
}

// When sets expectation for the TweetRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mTweetRepositoryMockUpdate) When(ctx context.Context, tweetID int, newText string) *TweetRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("TweetRepositoryMock.Update mock is already set by Set")
	}

	expectation := &TweetRepositoryMockUpdateExpectation{
		mock:   mmUpdate.mock,
		params: &TweetRepositoryMockUpdateParams{ctx, tweetID, newText},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up TweetRepository.Update return parameters for the expectation previously defined by the When method
func (e *TweetRepositoryMockUpdateExpectation) Then(err error) *TweetRepositoryMock {
	e.results = &TweetRepositoryMockUpdateResults{err}
	return e.mock
}

// Update implements usecase.TweetRepository
func (mmUpdate *TweetRepositoryMock) Update(ctx context.Context, tweetID int, newText string) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, tweetID, newText)
	}

	mm_params := &TweetRepositoryMockUpdateParams{ctx, tweetID, newText}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_got := TweetRepositoryMockUpdateParams{ctx, tweetID, newText}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("TweetRepositoryMock.Update got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the TweetRepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, tweetID, newText)
	}
	mmUpdate.t.Fatalf("Unexpected call to TweetRepositoryMock.Update. %v %v %v", ctx, tweetID, newText)
	return
}

// UpdateAfterCounter returns a count of finished TweetRepositoryMock.Update invocations
func (mmUpdate *TweetRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of TweetRepositoryMock.Update invocations
func (mmUpdate *TweetRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to TweetRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mTweetRepositoryMockUpdate) Calls() []*TweetRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*TweetRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *TweetRepositoryMock) MinimockUpdateDone() bool {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateInspect logs each unmet expectation
func (m *TweetRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TweetRepositoryMock.Update with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TweetRepositoryMock.Update")
		} else {
			m.t.Errorf("Expected call to TweetRepositoryMock.Update with params: %#v", *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		m.t.Error("Expected call to TweetRepositoryMock.Update")
	}
}

type mTweetRepositoryMockUpdateComment struct {
	mock               *TweetRepositoryMock
	defaultExpectation *TweetRepositoryMockUpdateCommentExpectation
	expectations       []*TweetRepositoryMockUpdateCommentExpectation

	callArgs []*TweetRepositoryMockUpdateCommentParams
	mutex    sync.RWMutex
}

// TweetRepositoryMockUpdateCommentExpectation specifies expectation struct of the TweetRepository.UpdateComment
type TweetRepositoryMockUpdateCommentExpectation struct {
	mock    *TweetRepositoryMock
	params  *TweetRepositoryMockUpdateCommentParams
	results *TweetRepositoryMockUpdateCommentResults
	Counter uint64
}

// TweetRepositoryMockUpdateCommentParams contains parameters of the TweetRepository.UpdateComment
type TweetRepositoryMockUpdateCommentParams struct {
	ctx       context.Context
	commentID int
	newText   string
}

// TweetRepositoryMockUpdateCommentResults contains results of the TweetRepository.UpdateComment
type TweetRepositoryMockUpdateCommentResults struct {
	err error
}

// Expect sets up expected params for TweetRepository.UpdateComment
func (mmUpdateComment *mTweetRepositoryMockUpdateComment) Expect(ctx context.Context, commentID int, newText string) *mTweetRepositoryMockUpdateComment {
	if mmUpdateComment.mock.funcUpdateComment != nil {
		mmUpdateComment.mock.t.Fatalf("TweetRepositoryMock.UpdateComment mock is already set by Set")
	}

	if mmUpdateComment.defaultExpectation == nil {
		mmUpdateComment.defaultExpectation = &TweetRepositoryMockUpdateCommentExpectation{}
	}

	mmUpdateComment.defaultExpectation.params = &TweetRepositoryMockUpdateCommentParams{ctx, commentID, newText}
	for _, e := range mmUpdateComment.expectations {
		if minimock.Equal(e.params, mmUpdateComment.defaultExpectation.params) {
			mmUpdateComment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateComment.defaultExpectation.params)
		}
	}

	return mmUpdateComment
}

// Inspect accepts an inspector function that has same arguments as the TweetRepository.UpdateComment
func (mmUpdateComment *mTweetRepositoryMockUpdateComment) Inspect(f func(ctx context.Context, commentID int, newText string)) *mTweetRepositoryMockUpdateComment {
	if mmUpdateComment.mock.inspectFuncUpdateComment != nil {
		mmUpdateComment.mock.t.Fatalf("Inspect function is already set for TweetRepositoryMock.UpdateComment")
	}

	mmUpdateComment.mock.inspectFuncUpdateComment = f

	return mmUpdateComment
}

// Return sets up results that will be returned by TweetRepository.UpdateComment
func (mmUpdateComment *mTweetRepositoryMockUpdateComment) Return(err error) *TweetRepositoryMock {
	if mmUpdateComment.mock.funcUpdateComment != nil {
		mmUpdateComment.mock.t.Fatalf("TweetRepositoryMock.UpdateComment mock is already set by Set")
	}

	if mmUpdateComment.defaultExpectation == nil {
		mmUpdateComment.defaultExpectation = &TweetRepositoryMockUpdateCommentExpectation{mock: mmUpdateComment.mock}
	}
	mmUpdateComment.defaultExpectation.results = &TweetRepositoryMockUpdateCommentResults{err}
	return mmUpdateComment.mock
}

// Set uses given function f to mock the TweetRepository.UpdateComment method
func (mmUpdateComment *mTweetRepositoryMockUpdateComment) Set(f func(ctx context.Context, commentID int, newText string) (err error)) *TweetRepositoryMock {
	if mmUpdateComment.defaultExpectation != nil {
		mmUpdateComment.mock.t.Fatalf("Default expectation is already set for the TweetRepository.UpdateComment method")
	}

	if len(mmUpdateComment.expectations) > 0 {
		mmUpdateComment.mock.t.Fatalf("Some expectations are already set for the TweetRepository.UpdateComment method")
	}

	mmUpdateComment.mock.funcUpdateComment = f
	return mmUpdateComment.mock
}

// When sets expectation for the TweetRepository.UpdateComment which will trigger the result defined by the following
// Then helper
func (mmUpdateComment *mTweetRepositoryMockUpdateComment) When(ctx context.Context, commentID int, newText string) *TweetRepositoryMockUpdateCommentExpectation {
	if mmUpdateComment.mock.funcUpdateComment != nil {
		mmUpdateComment.mock.t.Fatalf("TweetRepositoryMock.UpdateComment mock is already set by Set")
	}

	expectation := &TweetRepositoryMockUpdateCommentExpectation{
		mock:   mmUpdateComment.mock,
		params: &TweetRepositoryMockUpdateCommentParams{ctx, commentID, newText},
	}
	mmUpdateComment.expectations = append(mmUpdateComment.expectations, expectation)
	return expectation
}

// Then sets up TweetRepository.UpdateComment return parameters for the expectation previously defined by the When method
func (e *TweetRepositoryMockUpdateCommentExpectation) Then(err error) *TweetRepositoryMock {
	e.results = &TweetRepositoryMockUpdateCommentResults{err}
	return e.mock
}

// UpdateComment implements usecase.TweetRepository
func (mmUpdateComment *TweetRepositoryMock) UpdateComment(ctx context.Context, commentID int, newText string) (err error) {
	mm_atomic.AddUint64(&mmUpdateComment.beforeUpdateCommentCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateComment.afterUpdateCommentCounter, 1)

	if mmUpdateComment.inspectFuncUpdateComment != nil {
		mmUpdateComment.inspectFuncUpdateComment(ctx, commentID, newText)
	}

	mm_params := &TweetRepositoryMockUpdateCommentParams{ctx, commentID, newText}

	// Record call args
	mmUpdateComment.UpdateCommentMock.mutex.Lock()
	mmUpdateComment.UpdateCommentMock.callArgs = append(mmUpdateComment.UpdateCommentMock.callArgs, mm_params)
	mmUpdateComment.UpdateCommentMock.mutex.Unlock()

	for _, e := range mmUpdateComment.UpdateCommentMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateComment.UpdateCommentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateComment.UpdateCommentMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateComment.UpdateCommentMock.defaultExpectation.params
		mm_got := TweetRepositoryMockUpdateCommentParams{ctx, commentID, newText}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateComment.t.Errorf("TweetRepositoryMock.UpdateComment got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateComment.UpdateCommentMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateComment.t.Fatal("No results are set for the TweetRepositoryMock.UpdateComment")
		}
		return (*mm_results).err
	}
	if mmUpdateComment.funcUpdateComment != nil {
		return mmUpdateComment.funcUpdateComment(ctx, commentID, newText)
	}
	mmUpdateComment.t.Fatalf("Unexpected call to TweetRepositoryMock.UpdateComment. %v %v %v", ctx, commentID, newText)
	return
}

// UpdateCommentAfterCounter returns a count of finished TweetRepositoryMock.UpdateComment invocations
func (mmUpdateComment *TweetRepositoryMock) UpdateCommentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateComment.afterUpdateCommentCounter)
}

// UpdateCommentBeforeCounter returns a count of TweetRepositoryMock.UpdateComment invocations
func (mmUpdateComment *TweetRepositoryMock) UpdateCommentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateComment.beforeUpdateCommentCounter)
}

// Calls returns a list of arguments used in each call to TweetRepositoryMock.UpdateComment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateComment *mTweetRepositoryMockUpdateComment) Calls() []*TweetRepositoryMockUpdateCommentParams {
	mmUpdateComment.mutex.RLock()

	argCopy := make([]*TweetRepositoryMockUpdateCommentParams, len(mmUpdateComment.callArgs))
	copy(argCopy, mmUpdateComment.callArgs)

	mmUpdateComment.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateCommentDone returns true if the count of the UpdateComment invocations corresponds
// the number of defined expectations
func (m *TweetRepositoryMock) MinimockUpdateCommentDone() bool {
	for _, e := range m.UpdateCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCommentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCommentCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateComment != nil && mm_atomic.LoadUint64(&m.afterUpdateCommentCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateCommentInspect logs each unmet expectation
func (m *TweetRepositoryMock) MinimockUpdateCommentInspect() {
	for _, e := range m.UpdateCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TweetRepositoryMock.UpdateComment with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCommentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCommentCounter) < 1 {
		if m.UpdateCommentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TweetRepositoryMock.UpdateComment")
		} else {
			m.t.Errorf("Expected call to TweetRepositoryMock.UpdateComment with params: %#v", *m.UpdateCommentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateComment != nil && mm_atomic.LoadUint64(&m.afterUpdateCommentCounter) < 1 {
		m.t.Error("Expected call to TweetRepositoryMock.UpdateComment")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TweetRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddInspect()

		m.MinimockAddCommentInspect()

		m.MinimockGetLatestInspect()

		m.MinimockUpdateInspect()

		m.MinimockUpdateCommentInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TweetRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TweetRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddDone() &&
		m.MinimockAddCommentDone() &&
		m.MinimockGetLatestDone() &&
		m.MinimockUpdateDone() &&
		m.MinimockUpdateCommentDone()
}
