package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/demimurg/twitter/internal/entity"
	"github.com/gojuno/minimock/v3"
)

// FeedManagerMock implements usecase.FeedManager
type FeedManagerMock struct {
	t minimock.Tester

	funcAddFollower          func(ctx context.Context, userID int, toUserID int) (err error)
	inspectFuncAddFollower   func(ctx context.Context, userID int, toUserID int)
	afterAddFollowerCounter  uint64
	beforeAddFollowerCounter uint64
	AddFollowerMock          mFeedManagerMockAddFollower

	funcAddNewTweet          func(ctx context.Context, userID int, text string) (err error)
	inspectFuncAddNewTweet   func(ctx context.Context, userID int, text string)
	afterAddNewTweetCounter  uint64
	beforeAddNewTweetCounter uint64
	AddNewTweetMock          mFeedManagerMockAddNewTweet

	funcEditComment          func(ctx context.Context, commentID int, text string) (err error)
	inspectFuncEditComment   func(ctx context.Context, commentID int, text string)
	afterEditCommentCounter  uint64
	beforeEditCommentCounter uint64
	EditCommentMock          mFeedManagerMockEditComment

	funcEditTweet          func(ctx context.Context, tweetID int, text string) (err error)
	inspectFuncEditTweet   func(ctx context.Context, tweetID int, text string)
	afterEditTweetCounter  uint64
	beforeEditTweetCounter uint64
	EditTweetMock          mFeedManagerMockEditTweet

	funcGiveNewsFeed          func(ctx context.Context, userID int) (ta1 []entity.Tweet, err error)
	inspectFuncGiveNewsFeed   func(ctx context.Context, userID int)
	afterGiveNewsFeedCounter  uint64
	beforeGiveNewsFeedCounter uint64
	GiveNewsFeedMock          mFeedManagerMockGiveNewsFeed

	funcRemoveFollower          func(ctx context.Context, userID int, fromUserID int) (err error)
	inspectFuncRemoveFollower   func(ctx context.Context, userID int, fromUserID int)
	afterRemoveFollowerCounter  uint64
	beforeRemoveFollowerCounter uint64
	RemoveFollowerMock          mFeedManagerMockRemoveFollower
}

// NewFeedManagerMock returns a mock for usecase.FeedManager
func NewFeedManagerMock(t minimock.Tester) *FeedManagerMock {
	m := &FeedManagerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddFollowerMock = mFeedManagerMockAddFollower{mock: m}
	m.AddFollowerMock.callArgs = []*FeedManagerMockAddFollowerParams{}

	m.AddNewTweetMock = mFeedManagerMockAddNewTweet{mock: m}
	m.AddNewTweetMock.callArgs = []*FeedManagerMockAddNewTweetParams{}

	m.EditCommentMock = mFeedManagerMockEditComment{mock: m}
	m.EditCommentMock.callArgs = []*FeedManagerMockEditCommentParams{}

	m.EditTweetMock = mFeedManagerMockEditTweet{mock: m}
	m.EditTweetMock.callArgs = []*FeedManagerMockEditTweetParams{}

	m.GiveNewsFeedMock = mFeedManagerMockGiveNewsFeed{mock: m}
	m.GiveNewsFeedMock.callArgs = []*FeedManagerMockGiveNewsFeedParams{}

	m.RemoveFollowerMock = mFeedManagerMockRemoveFollower{mock: m}
	m.RemoveFollowerMock.callArgs = []*FeedManagerMockRemoveFollowerParams{}

	return m
}

type mFeedManagerMockAddFollower struct {
	mock               *FeedManagerMock
	defaultExpectation *FeedManagerMockAddFollowerExpectation
	expectations       []*FeedManagerMockAddFollowerExpectation

	callArgs []*FeedManagerMockAddFollowerParams
	mutex    sync.RWMutex
}

// FeedManagerMockAddFollowerExpectation specifies expectation struct of the FeedManager.AddFollower
type FeedManagerMockAddFollowerExpectation struct {
	mock    *FeedManagerMock
	params  *FeedManagerMockAddFollowerParams
	results *FeedManagerMockAddFollowerResults
	Counter uint64
}

// FeedManagerMockAddFollowerParams contains parameters of the FeedManager.AddFollower
type FeedManagerMockAddFollowerParams struct {
	ctx      context.Context
	userID   int
	toUserID int
}

// FeedManagerMockAddFollowerResults contains results of the FeedManager.AddFollower
type FeedManagerMockAddFollowerResults struct {
	err error
}

// Expect sets up expected params for FeedManager.AddFollower
func (mmAddFollower *mFeedManagerMockAddFollower) Expect(ctx context.Context, userID int, toUserID int) *mFeedManagerMockAddFollower {
	if mmAddFollower.mock.funcAddFollower != nil {
		mmAddFollower.mock.t.Fatalf("FeedManagerMock.AddFollower mock is already set by Set")
	}

	if mmAddFollower.defaultExpectation == nil {
		mmAddFollower.defaultExpectation = &FeedManagerMockAddFollowerExpectation{}
	}

	mmAddFollower.defaultExpectation.params = &FeedManagerMockAddFollowerParams{ctx, userID, toUserID}
	for _, e := range mmAddFollower.expectations {
		if minimock.Equal(e.params, mmAddFollower.defaultExpectation.params) {
			mmAddFollower.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddFollower.defaultExpectation.params)
		}
	}

	return mmAddFollower
}

// Inspect accepts an inspector function that has same arguments as the FeedManager.AddFollower
func (mmAddFollower *mFeedManagerMockAddFollower) Inspect(f func(ctx context.Context, userID int, toUserID int)) *mFeedManagerMockAddFollower {
	if mmAddFollower.mock.inspectFuncAddFollower != nil {
		mmAddFollower.mock.t.Fatalf("Inspect function is already set for FeedManagerMock.AddFollower")
	}

	mmAddFollower.mock.inspectFuncAddFollower = f

	return mmAddFollower
}

// Return sets up results that will be returned by FeedManager.AddFollower
func (mmAddFollower *mFeedManagerMockAddFollower) Return(err error) *FeedManagerMock {
	if mmAddFollower.mock.funcAddFollower != nil {
		mmAddFollower.mock.t.Fatalf("FeedManagerMock.AddFollower mock is already set by Set")
	}

	if mmAddFollower.defaultExpectation == nil {
		mmAddFollower.defaultExpectation = &FeedManagerMockAddFollowerExpectation{mock: mmAddFollower.mock}
	}
	mmAddFollower.defaultExpectation.results = &FeedManagerMockAddFollowerResults{err}
	return mmAddFollower.mock
}

//Set uses given function f to mock the FeedManager.AddFollower method
func (mmAddFollower *mFeedManagerMockAddFollower) Set(f func(ctx context.Context, userID int, toUserID int) (err error)) *FeedManagerMock {
	if mmAddFollower.defaultExpectation != nil {
		mmAddFollower.mock.t.Fatalf("Default expectation is already set for the FeedManager.AddFollower method")
	}

	if len(mmAddFollower.expectations) > 0 {
		mmAddFollower.mock.t.Fatalf("Some expectations are already set for the FeedManager.AddFollower method")
	}

	mmAddFollower.mock.funcAddFollower = f
	return mmAddFollower.mock
}

// When sets expectation for the FeedManager.AddFollower which will trigger the result defined by the following
// Then helper
func (mmAddFollower *mFeedManagerMockAddFollower) When(ctx context.Context, userID int, toUserID int) *FeedManagerMockAddFollowerExpectation {
	if mmAddFollower.mock.funcAddFollower != nil {
		mmAddFollower.mock.t.Fatalf("FeedManagerMock.AddFollower mock is already set by Set")
	}

	expectation := &FeedManagerMockAddFollowerExpectation{
		mock:   mmAddFollower.mock,
		params: &FeedManagerMockAddFollowerParams{ctx, userID, toUserID},
	}
	mmAddFollower.expectations = append(mmAddFollower.expectations, expectation)
	return expectation
}

// Then sets up FeedManager.AddFollower return parameters for the expectation previously defined by the When method
func (e *FeedManagerMockAddFollowerExpectation) Then(err error) *FeedManagerMock {
	e.results = &FeedManagerMockAddFollowerResults{err}
	return e.mock
}

// AddFollower implements usecase.FeedManager
func (mmAddFollower *FeedManagerMock) AddFollower(ctx context.Context, userID int, toUserID int) (err error) {
	mm_atomic.AddUint64(&mmAddFollower.beforeAddFollowerCounter, 1)
	defer mm_atomic.AddUint64(&mmAddFollower.afterAddFollowerCounter, 1)

	if mmAddFollower.inspectFuncAddFollower != nil {
		mmAddFollower.inspectFuncAddFollower(ctx, userID, toUserID)
	}

	mm_params := &FeedManagerMockAddFollowerParams{ctx, userID, toUserID}

	// Record call args
	mmAddFollower.AddFollowerMock.mutex.Lock()
	mmAddFollower.AddFollowerMock.callArgs = append(mmAddFollower.AddFollowerMock.callArgs, mm_params)
	mmAddFollower.AddFollowerMock.mutex.Unlock()

	for _, e := range mmAddFollower.AddFollowerMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddFollower.AddFollowerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddFollower.AddFollowerMock.defaultExpectation.Counter, 1)
		mm_want := mmAddFollower.AddFollowerMock.defaultExpectation.params
		mm_got := FeedManagerMockAddFollowerParams{ctx, userID, toUserID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddFollower.t.Errorf("FeedManagerMock.AddFollower got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddFollower.AddFollowerMock.defaultExpectation.results
		if mm_results == nil {
			mmAddFollower.t.Fatal("No results are set for the FeedManagerMock.AddFollower")
		}
		return (*mm_results).err
	}
	if mmAddFollower.funcAddFollower != nil {
		return mmAddFollower.funcAddFollower(ctx, userID, toUserID)
	}
	mmAddFollower.t.Fatalf("Unexpected call to FeedManagerMock.AddFollower. %v %v %v", ctx, userID, toUserID)
	return
}

// AddFollowerAfterCounter returns a count of finished FeedManagerMock.AddFollower invocations
func (mmAddFollower *FeedManagerMock) AddFollowerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddFollower.afterAddFollowerCounter)
}

// AddFollowerBeforeCounter returns a count of FeedManagerMock.AddFollower invocations
func (mmAddFollower *FeedManagerMock) AddFollowerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddFollower.beforeAddFollowerCounter)
}

// Calls returns a list of arguments used in each call to FeedManagerMock.AddFollower.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddFollower *mFeedManagerMockAddFollower) Calls() []*FeedManagerMockAddFollowerParams {
	mmAddFollower.mutex.RLock()

	argCopy := make([]*FeedManagerMockAddFollowerParams, len(mmAddFollower.callArgs))
	copy(argCopy, mmAddFollower.callArgs)

	mmAddFollower.mutex.RUnlock()

	return argCopy
}

// MinimockAddFollowerDone returns true if the count of the AddFollower invocations corresponds
// the number of defined expectations
func (m *FeedManagerMock) MinimockAddFollowerDone() bool {
	for _, e := range m.AddFollowerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddFollowerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddFollowerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddFollower != nil && mm_atomic.LoadUint64(&m.afterAddFollowerCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddFollowerInspect logs each unmet expectation
func (m *FeedManagerMock) MinimockAddFollowerInspect() {
	for _, e := range m.AddFollowerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FeedManagerMock.AddFollower with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddFollowerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddFollowerCounter) < 1 {
		if m.AddFollowerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FeedManagerMock.AddFollower")
		} else {
			m.t.Errorf("Expected call to FeedManagerMock.AddFollower with params: %#v", *m.AddFollowerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddFollower != nil && mm_atomic.LoadUint64(&m.afterAddFollowerCounter) < 1 {
		m.t.Error("Expected call to FeedManagerMock.AddFollower")
	}
}

type mFeedManagerMockAddNewTweet struct {
	mock               *FeedManagerMock
	defaultExpectation *FeedManagerMockAddNewTweetExpectation
	expectations       []*FeedManagerMockAddNewTweetExpectation

	callArgs []*FeedManagerMockAddNewTweetParams
	mutex    sync.RWMutex
}

// FeedManagerMockAddNewTweetExpectation specifies expectation struct of the FeedManager.AddNewTweet
type FeedManagerMockAddNewTweetExpectation struct {
	mock    *FeedManagerMock
	params  *FeedManagerMockAddNewTweetParams
	results *FeedManagerMockAddNewTweetResults
	Counter uint64
}

// FeedManagerMockAddNewTweetParams contains parameters of the FeedManager.AddNewTweet
type FeedManagerMockAddNewTweetParams struct {
	ctx    context.Context
	userID int
	text   string
}

// FeedManagerMockAddNewTweetResults contains results of the FeedManager.AddNewTweet
type FeedManagerMockAddNewTweetResults struct {
	err error
}

// Expect sets up expected params for FeedManager.AddNewTweet
func (mmAddNewTweet *mFeedManagerMockAddNewTweet) Expect(ctx context.Context, userID int, text string) *mFeedManagerMockAddNewTweet {
	if mmAddNewTweet.mock.funcAddNewTweet != nil {
		mmAddNewTweet.mock.t.Fatalf("FeedManagerMock.AddNewTweet mock is already set by Set")
	}

	if mmAddNewTweet.defaultExpectation == nil {
		mmAddNewTweet.defaultExpectation = &FeedManagerMockAddNewTweetExpectation{}
	}

	mmAddNewTweet.defaultExpectation.params = &FeedManagerMockAddNewTweetParams{ctx, userID, text}
	for _, e := range mmAddNewTweet.expectations {
		if minimock.Equal(e.params, mmAddNewTweet.defaultExpectation.params) {
			mmAddNewTweet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddNewTweet.defaultExpectation.params)
		}
	}

	return mmAddNewTweet
}

// Inspect accepts an inspector function that has same arguments as the FeedManager.AddNewTweet
func (mmAddNewTweet *mFeedManagerMockAddNewTweet) Inspect(f func(ctx context.Context, userID int, text string)) *mFeedManagerMockAddNewTweet {
	if mmAddNewTweet.mock.inspectFuncAddNewTweet != nil {
		mmAddNewTweet.mock.t.Fatalf("Inspect function is already set for FeedManagerMock.AddNewTweet")
	}

	mmAddNewTweet.mock.inspectFuncAddNewTweet = f

	return mmAddNewTweet
}

// Return sets up results that will be returned by FeedManager.AddNewTweet
func (mmAddNewTweet *mFeedManagerMockAddNewTweet) Return(err error) *FeedManagerMock {
	if mmAddNewTweet.mock.funcAddNewTweet != nil {
		mmAddNewTweet.mock.t.Fatalf("FeedManagerMock.AddNewTweet mock is already set by Set")
	}

	if mmAddNewTweet.defaultExpectation == nil {
		mmAddNewTweet.defaultExpectation = &FeedManagerMockAddNewTweetExpectation{mock: mmAddNewTweet.mock}
	}
	mmAddNewTweet.defaultExpectation.results = &FeedManagerMockAddNewTweetResults{err}
	return mmAddNewTweet.mock
}

//Set uses given function f to mock the FeedManager.AddNewTweet method
func (mmAddNewTweet *mFeedManagerMockAddNewTweet) Set(f func(ctx context.Context, userID int, text string) (err error)) *FeedManagerMock {
	if mmAddNewTweet.defaultExpectation != nil {
		mmAddNewTweet.mock.t.Fatalf("Default expectation is already set for the FeedManager.AddNewTweet method")
	}

	if len(mmAddNewTweet.expectations) > 0 {
		mmAddNewTweet.mock.t.Fatalf("Some expectations are already set for the FeedManager.AddNewTweet method")
	}

	mmAddNewTweet.mock.funcAddNewTweet = f
	return mmAddNewTweet.mock
}

// When sets expectation for the FeedManager.AddNewTweet which will trigger the result defined by the following
// Then helper
func (mmAddNewTweet *mFeedManagerMockAddNewTweet) When(ctx context.Context, userID int, text string) *FeedManagerMockAddNewTweetExpectation {
	if mmAddNewTweet.mock.funcAddNewTweet != nil {
		mmAddNewTweet.mock.t.Fatalf("FeedManagerMock.AddNewTweet mock is already set by Set")
	}

	expectation := &FeedManagerMockAddNewTweetExpectation{
		mock:   mmAddNewTweet.mock,
		params: &FeedManagerMockAddNewTweetParams{ctx, userID, text},
	}
	mmAddNewTweet.expectations = append(mmAddNewTweet.expectations, expectation)
	return expectation
}

// Then sets up FeedManager.AddNewTweet return parameters for the expectation previously defined by the When method
func (e *FeedManagerMockAddNewTweetExpectation) Then(err error) *FeedManagerMock {
	e.results = &FeedManagerMockAddNewTweetResults{err}
	return e.mock
}

// AddNewTweet implements usecase.FeedManager
func (mmAddNewTweet *FeedManagerMock) AddNewTweet(ctx context.Context, userID int, text string) (err error) {
	mm_atomic.AddUint64(&mmAddNewTweet.beforeAddNewTweetCounter, 1)
	defer mm_atomic.AddUint64(&mmAddNewTweet.afterAddNewTweetCounter, 1)

	if mmAddNewTweet.inspectFuncAddNewTweet != nil {
		mmAddNewTweet.inspectFuncAddNewTweet(ctx, userID, text)
	}

	mm_params := &FeedManagerMockAddNewTweetParams{ctx, userID, text}

	// Record call args
	mmAddNewTweet.AddNewTweetMock.mutex.Lock()
	mmAddNewTweet.AddNewTweetMock.callArgs = append(mmAddNewTweet.AddNewTweetMock.callArgs, mm_params)
	mmAddNewTweet.AddNewTweetMock.mutex.Unlock()

	for _, e := range mmAddNewTweet.AddNewTweetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddNewTweet.AddNewTweetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddNewTweet.AddNewTweetMock.defaultExpectation.Counter, 1)
		mm_want := mmAddNewTweet.AddNewTweetMock.defaultExpectation.params
		mm_got := FeedManagerMockAddNewTweetParams{ctx, userID, text}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddNewTweet.t.Errorf("FeedManagerMock.AddNewTweet got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddNewTweet.AddNewTweetMock.defaultExpectation.results
		if mm_results == nil {
			mmAddNewTweet.t.Fatal("No results are set for the FeedManagerMock.AddNewTweet")
		}
		return (*mm_results).err
	}
	if mmAddNewTweet.funcAddNewTweet != nil {
		return mmAddNewTweet.funcAddNewTweet(ctx, userID, text)
	}
	mmAddNewTweet.t.Fatalf("Unexpected call to FeedManagerMock.AddNewTweet. %v %v %v", ctx, userID, text)
	return
}

// AddNewTweetAfterCounter returns a count of finished FeedManagerMock.AddNewTweet invocations
func (mmAddNewTweet *FeedManagerMock) AddNewTweetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddNewTweet.afterAddNewTweetCounter)
}

// AddNewTweetBeforeCounter returns a count of FeedManagerMock.AddNewTweet invocations
func (mmAddNewTweet *FeedManagerMock) AddNewTweetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddNewTweet.beforeAddNewTweetCounter)
}

// Calls returns a list of arguments used in each call to FeedManagerMock.AddNewTweet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddNewTweet *mFeedManagerMockAddNewTweet) Calls() []*FeedManagerMockAddNewTweetParams {
	mmAddNewTweet.mutex.RLock()

	argCopy := make([]*FeedManagerMockAddNewTweetParams, len(mmAddNewTweet.callArgs))
	copy(argCopy, mmAddNewTweet.callArgs)

	mmAddNewTweet.mutex.RUnlock()

	return argCopy
}

// MinimockAddNewTweetDone returns true if the count of the AddNewTweet invocations corresponds
// the number of defined expectations
func (m *FeedManagerMock) MinimockAddNewTweetDone() bool {
	for _, e := range m.AddNewTweetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddNewTweetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddNewTweetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddNewTweet != nil && mm_atomic.LoadUint64(&m.afterAddNewTweetCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddNewTweetInspect logs each unmet expectation
func (m *FeedManagerMock) MinimockAddNewTweetInspect() {
	for _, e := range m.AddNewTweetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FeedManagerMock.AddNewTweet with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddNewTweetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddNewTweetCounter) < 1 {
		if m.AddNewTweetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FeedManagerMock.AddNewTweet")
		} else {
			m.t.Errorf("Expected call to FeedManagerMock.AddNewTweet with params: %#v", *m.AddNewTweetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddNewTweet != nil && mm_atomic.LoadUint64(&m.afterAddNewTweetCounter) < 1 {
		m.t.Error("Expected call to FeedManagerMock.AddNewTweet")
	}
}

type mFeedManagerMockEditComment struct {
	mock               *FeedManagerMock
	defaultExpectation *FeedManagerMockEditCommentExpectation
	expectations       []*FeedManagerMockEditCommentExpectation

	callArgs []*FeedManagerMockEditCommentParams
	mutex    sync.RWMutex
}

// FeedManagerMockEditCommentExpectation specifies expectation struct of the FeedManager.EditComment
type FeedManagerMockEditCommentExpectation struct {
	mock    *FeedManagerMock
	params  *FeedManagerMockEditCommentParams
	results *FeedManagerMockEditCommentResults
	Counter uint64
}

// FeedManagerMockEditCommentParams contains parameters of the FeedManager.EditComment
type FeedManagerMockEditCommentParams struct {
	ctx       context.Context
	commentID int
	text      string
}

// FeedManagerMockEditCommentResults contains results of the FeedManager.EditComment
type FeedManagerMockEditCommentResults struct {
	err error
}

// Expect sets up expected params for FeedManager.EditComment
func (mmEditComment *mFeedManagerMockEditComment) Expect(ctx context.Context, commentID int, text string) *mFeedManagerMockEditComment {
	if mmEditComment.mock.funcEditComment != nil {
		mmEditComment.mock.t.Fatalf("FeedManagerMock.EditComment mock is already set by Set")
	}

	if mmEditComment.defaultExpectation == nil {
		mmEditComment.defaultExpectation = &FeedManagerMockEditCommentExpectation{}
	}

	mmEditComment.defaultExpectation.params = &FeedManagerMockEditCommentParams{ctx, commentID, text}
	for _, e := range mmEditComment.expectations {
		if minimock.Equal(e.params, mmEditComment.defaultExpectation.params) {
			mmEditComment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEditComment.defaultExpectation.params)
		}
	}

	return mmEditComment
}

// Inspect accepts an inspector function that has same arguments as the FeedManager.EditComment
func (mmEditComment *mFeedManagerMockEditComment) Inspect(f func(ctx context.Context, commentID int, text string)) *mFeedManagerMockEditComment {
	if mmEditComment.mock.inspectFuncEditComment != nil {
		mmEditComment.mock.t.Fatalf("Inspect function is already set for FeedManagerMock.EditComment")
	}

	mmEditComment.mock.inspectFuncEditComment = f

	return mmEditComment
}

// Return sets up results that will be returned by FeedManager.EditComment
func (mmEditComment *mFeedManagerMockEditComment) Return(err error) *FeedManagerMock {
	if mmEditComment.mock.funcEditComment != nil {
		mmEditComment.mock.t.Fatalf("FeedManagerMock.EditComment mock is already set by Set")
	}

	if mmEditComment.defaultExpectation == nil {
		mmEditComment.defaultExpectation = &FeedManagerMockEditCommentExpectation{mock: mmEditComment.mock}
	}
	mmEditComment.defaultExpectation.results = &FeedManagerMockEditCommentResults{err}
	return mmEditComment.mock
}

//Set uses given function f to mock the FeedManager.EditComment method
func (mmEditComment *mFeedManagerMockEditComment) Set(f func(ctx context.Context, commentID int, text string) (err error)) *FeedManagerMock {
	if mmEditComment.defaultExpectation != nil {
		mmEditComment.mock.t.Fatalf("Default expectation is already set for the FeedManager.EditComment method")
	}

	if len(mmEditComment.expectations) > 0 {
		mmEditComment.mock.t.Fatalf("Some expectations are already set for the FeedManager.EditComment method")
	}

	mmEditComment.mock.funcEditComment = f
	return mmEditComment.mock
}

// When sets expectation for the FeedManager.EditComment which will trigger the result defined by the following
// Then helper
func (mmEditComment *mFeedManagerMockEditComment) When(ctx context.Context, commentID int, text string) *FeedManagerMockEditCommentExpectation {
	if mmEditComment.mock.funcEditComment != nil {
		mmEditComment.mock.t.Fatalf("FeedManagerMock.EditComment mock is already set by Set")
	}

	expectation := &FeedManagerMockEditCommentExpectation{
		mock:   mmEditComment.mock,
		params: &FeedManagerMockEditCommentParams{ctx, commentID, text},
	}
	mmEditComment.expectations = append(mmEditComment.expectations, expectation)
	return expectation
}

// Then sets up FeedManager.EditComment return parameters for the expectation previously defined by the When method
func (e *FeedManagerMockEditCommentExpectation) Then(err error) *FeedManagerMock {
	e.results = &FeedManagerMockEditCommentResults{err}
	return e.mock
}

// EditComment implements usecase.FeedManager
func (mmEditComment *FeedManagerMock) EditComment(ctx context.Context, commentID int, text string) (err error) {
	mm_atomic.AddUint64(&mmEditComment.beforeEditCommentCounter, 1)
	defer mm_atomic.AddUint64(&mmEditComment.afterEditCommentCounter, 1)

	if mmEditComment.inspectFuncEditComment != nil {
		mmEditComment.inspectFuncEditComment(ctx, commentID, text)
	}

	mm_params := &FeedManagerMockEditCommentParams{ctx, commentID, text}

	// Record call args
	mmEditComment.EditCommentMock.mutex.Lock()
	mmEditComment.EditCommentMock.callArgs = append(mmEditComment.EditCommentMock.callArgs, mm_params)
	mmEditComment.EditCommentMock.mutex.Unlock()

	for _, e := range mmEditComment.EditCommentMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmEditComment.EditCommentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEditComment.EditCommentMock.defaultExpectation.Counter, 1)
		mm_want := mmEditComment.EditCommentMock.defaultExpectation.params
		mm_got := FeedManagerMockEditCommentParams{ctx, commentID, text}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEditComment.t.Errorf("FeedManagerMock.EditComment got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEditComment.EditCommentMock.defaultExpectation.results
		if mm_results == nil {
			mmEditComment.t.Fatal("No results are set for the FeedManagerMock.EditComment")
		}
		return (*mm_results).err
	}
	if mmEditComment.funcEditComment != nil {
		return mmEditComment.funcEditComment(ctx, commentID, text)
	}
	mmEditComment.t.Fatalf("Unexpected call to FeedManagerMock.EditComment. %v %v %v", ctx, commentID, text)
	return
}

// EditCommentAfterCounter returns a count of finished FeedManagerMock.EditComment invocations
func (mmEditComment *FeedManagerMock) EditCommentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEditComment.afterEditCommentCounter)
}

// EditCommentBeforeCounter returns a count of FeedManagerMock.EditComment invocations
func (mmEditComment *FeedManagerMock) EditCommentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEditComment.beforeEditCommentCounter)
}

// Calls returns a list of arguments used in each call to FeedManagerMock.EditComment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEditComment *mFeedManagerMockEditComment) Calls() []*FeedManagerMockEditCommentParams {
	mmEditComment.mutex.RLock()

	argCopy := make([]*FeedManagerMockEditCommentParams, len(mmEditComment.callArgs))
	copy(argCopy, mmEditComment.callArgs)

	mmEditComment.mutex.RUnlock()

	return argCopy
}

// MinimockEditCommentDone returns true if the count of the EditComment invocations corresponds
// the number of defined expectations
func (m *FeedManagerMock) MinimockEditCommentDone() bool {
	for _, e := range m.EditCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EditCommentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEditCommentCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEditComment != nil && mm_atomic.LoadUint64(&m.afterEditCommentCounter) < 1 {
		return false
	}
	return true
}

// MinimockEditCommentInspect logs each unmet expectation
func (m *FeedManagerMock) MinimockEditCommentInspect() {
	for _, e := range m.EditCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FeedManagerMock.EditComment with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EditCommentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEditCommentCounter) < 1 {
		if m.EditCommentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FeedManagerMock.EditComment")
		} else {
			m.t.Errorf("Expected call to FeedManagerMock.EditComment with params: %#v", *m.EditCommentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEditComment != nil && mm_atomic.LoadUint64(&m.afterEditCommentCounter) < 1 {
		m.t.Error("Expected call to FeedManagerMock.EditComment")
	}
}

type mFeedManagerMockEditTweet struct {
	mock               *FeedManagerMock
	defaultExpectation *FeedManagerMockEditTweetExpectation
	expectations       []*FeedManagerMockEditTweetExpectation

	callArgs []*FeedManagerMockEditTweetParams
	mutex    sync.RWMutex
}

// FeedManagerMockEditTweetExpectation specifies expectation struct of the FeedManager.EditTweet
type FeedManagerMockEditTweetExpectation struct {
	mock    *FeedManagerMock
	params  *FeedManagerMockEditTweetParams
	results *FeedManagerMockEditTweetResults
	Counter uint64
}

// FeedManagerMockEditTweetParams contains parameters of the FeedManager.EditTweet
type FeedManagerMockEditTweetParams struct {
	ctx     context.Context
	tweetID int
	text    string
}

// FeedManagerMockEditTweetResults contains results of the FeedManager.EditTweet
type FeedManagerMockEditTweetResults struct {
	err error
}

// Expect sets up expected params for FeedManager.EditTweet
func (mmEditTweet *mFeedManagerMockEditTweet) Expect(ctx context.Context, tweetID int, text string) *mFeedManagerMockEditTweet {
	if mmEditTweet.mock.funcEditTweet != nil {
		mmEditTweet.mock.t.Fatalf("FeedManagerMock.EditTweet mock is already set by Set")
	}

	if mmEditTweet.defaultExpectation == nil {
		mmEditTweet.defaultExpectation = &FeedManagerMockEditTweetExpectation{}
	}

	mmEditTweet.defaultExpectation.params = &FeedManagerMockEditTweetParams{ctx, tweetID, text}
	for _, e := range mmEditTweet.expectations {
		if minimock.Equal(e.params, mmEditTweet.defaultExpectation.params) {
			mmEditTweet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEditTweet.defaultExpectation.params)
		}
	}

	return mmEditTweet
}

// Inspect accepts an inspector function that has same arguments as the FeedManager.EditTweet
func (mmEditTweet *mFeedManagerMockEditTweet) Inspect(f func(ctx context.Context, tweetID int, text string)) *mFeedManagerMockEditTweet {
	if mmEditTweet.mock.inspectFuncEditTweet != nil {
		mmEditTweet.mock.t.Fatalf("Inspect function is already set for FeedManagerMock.EditTweet")
	}

	mmEditTweet.mock.inspectFuncEditTweet = f

	return mmEditTweet
}

// Return sets up results that will be returned by FeedManager.EditTweet
func (mmEditTweet *mFeedManagerMockEditTweet) Return(err error) *FeedManagerMock {
	if mmEditTweet.mock.funcEditTweet != nil {
		mmEditTweet.mock.t.Fatalf("FeedManagerMock.EditTweet mock is already set by Set")
	}

	if mmEditTweet.defaultExpectation == nil {
		mmEditTweet.defaultExpectation = &FeedManagerMockEditTweetExpectation{mock: mmEditTweet.mock}
	}
	mmEditTweet.defaultExpectation.results = &FeedManagerMockEditTweetResults{err}
	return mmEditTweet.mock
}

//Set uses given function f to mock the FeedManager.EditTweet method
func (mmEditTweet *mFeedManagerMockEditTweet) Set(f func(ctx context.Context, tweetID int, text string) (err error)) *FeedManagerMock {
	if mmEditTweet.defaultExpectation != nil {
		mmEditTweet.mock.t.Fatalf("Default expectation is already set for the FeedManager.EditTweet method")
	}

	if len(mmEditTweet.expectations) > 0 {
		mmEditTweet.mock.t.Fatalf("Some expectations are already set for the FeedManager.EditTweet method")
	}

	mmEditTweet.mock.funcEditTweet = f
	return mmEditTweet.mock
}

// When sets expectation for the FeedManager.EditTweet which will trigger the result defined by the following
// Then helper
func (mmEditTweet *mFeedManagerMockEditTweet) When(ctx context.Context, tweetID int, text string) *FeedManagerMockEditTweetExpectation {
	if mmEditTweet.mock.funcEditTweet != nil {
		mmEditTweet.mock.t.Fatalf("FeedManagerMock.EditTweet mock is already set by Set")
	}

	expectation := &FeedManagerMockEditTweetExpectation{
		mock:   mmEditTweet.mock,
		params: &FeedManagerMockEditTweetParams{ctx, tweetID, text},
	}
	mmEditTweet.expectations = append(mmEditTweet.expectations, expectation)
	return expectation
}

// Then sets up FeedManager.EditTweet return parameters for the expectation previously defined by the When method
func (e *FeedManagerMockEditTweetExpectation) Then(err error) *FeedManagerMock {
	e.results = &FeedManagerMockEditTweetResults{err}
	return e.mock
}

// EditTweet implements usecase.FeedManager
func (mmEditTweet *FeedManagerMock) EditTweet(ctx context.Context, tweetID int, text string) (err error) {
	mm_atomic.AddUint64(&mmEditTweet.beforeEditTweetCounter, 1)
	defer mm_atomic.AddUint64(&mmEditTweet.afterEditTweetCounter, 1)

	if mmEditTweet.inspectFuncEditTweet != nil {
		mmEditTweet.inspectFuncEditTweet(ctx, tweetID, text)
	}

	mm_params := &FeedManagerMockEditTweetParams{ctx, tweetID, text}

	// Record call args
	mmEditTweet.EditTweetMock.mutex.Lock()
	mmEditTweet.EditTweetMock.callArgs = append(mmEditTweet.EditTweetMock.callArgs, mm_params)
	mmEditTweet.EditTweetMock.mutex.Unlock()

	for _, e := range mmEditTweet.EditTweetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmEditTweet.EditTweetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEditTweet.EditTweetMock.defaultExpectation.Counter, 1)
		mm_want := mmEditTweet.EditTweetMock.defaultExpectation.params
		mm_got := FeedManagerMockEditTweetParams{ctx, tweetID, text}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEditTweet.t.Errorf("FeedManagerMock.EditTweet got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEditTweet.EditTweetMock.defaultExpectation.results
		if mm_results == nil {
			mmEditTweet.t.Fatal("No results are set for the FeedManagerMock.EditTweet")
		}
		return (*mm_results).err
	}
	if mmEditTweet.funcEditTweet != nil {
		return mmEditTweet.funcEditTweet(ctx, tweetID, text)
	}
	mmEditTweet.t.Fatalf("Unexpected call to FeedManagerMock.EditTweet. %v %v %v", ctx, tweetID, text)
	return
}

// EditTweetAfterCounter returns a count of finished FeedManagerMock.EditTweet invocations
func (mmEditTweet *FeedManagerMock) EditTweetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEditTweet.afterEditTweetCounter)
}

// EditTweetBeforeCounter returns a count of FeedManagerMock.EditTweet invocations
func (mmEditTweet *FeedManagerMock) EditTweetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEditTweet.beforeEditTweetCounter)
}

// Calls returns a list of arguments used in each call to FeedManagerMock.EditTweet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEditTweet *mFeedManagerMockEditTweet) Calls() []*FeedManagerMockEditTweetParams {
	mmEditTweet.mutex.RLock()

	argCopy := make([]*FeedManagerMockEditTweetParams, len(mmEditTweet.callArgs))
	copy(argCopy, mmEditTweet.callArgs)

	mmEditTweet.mutex.RUnlock()

	return argCopy
}

// MinimockEditTweetDone returns true if the count of the EditTweet invocations corresponds
// the number of defined expectations
func (m *FeedManagerMock) MinimockEditTweetDone() bool {
	for _, e := range m.EditTweetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EditTweetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEditTweetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEditTweet != nil && mm_atomic.LoadUint64(&m.afterEditTweetCounter) < 1 {
		return false
	}
	return true
}

// MinimockEditTweetInspect logs each unmet expectation
func (m *FeedManagerMock) MinimockEditTweetInspect() {
	for _, e := range m.EditTweetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FeedManagerMock.EditTweet with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EditTweetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEditTweetCounter) < 1 {
		if m.EditTweetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FeedManagerMock.EditTweet")
		} else {
			m.t.Errorf("Expected call to FeedManagerMock.EditTweet with params: %#v", *m.EditTweetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEditTweet != nil && mm_atomic.LoadUint64(&m.afterEditTweetCounter) < 1 {
		m.t.Error("Expected call to FeedManagerMock.EditTweet")
	}
}

type mFeedManagerMockGiveNewsFeed struct {
	mock               *FeedManagerMock
	defaultExpectation *FeedManagerMockGiveNewsFeedExpectation
	expectations       []*FeedManagerMockGiveNewsFeedExpectation

	callArgs []*FeedManagerMockGiveNewsFeedParams
	mutex    sync.RWMutex
}

// FeedManagerMockGiveNewsFeedExpectation specifies expectation struct of the FeedManager.GiveNewsFeed
type FeedManagerMockGiveNewsFeedExpectation struct {
	mock    *FeedManagerMock
	params  *FeedManagerMockGiveNewsFeedParams
	results *FeedManagerMockGiveNewsFeedResults
	Counter uint64
}

// FeedManagerMockGiveNewsFeedParams contains parameters of the FeedManager.GiveNewsFeed
type FeedManagerMockGiveNewsFeedParams struct {
	ctx    context.Context
	userID int
}

// FeedManagerMockGiveNewsFeedResults contains results of the FeedManager.GiveNewsFeed
type FeedManagerMockGiveNewsFeedResults struct {
	ta1 []entity.Tweet
	err error
}

// Expect sets up expected params for FeedManager.GiveNewsFeed
func (mmGiveNewsFeed *mFeedManagerMockGiveNewsFeed) Expect(ctx context.Context, userID int) *mFeedManagerMockGiveNewsFeed {
	if mmGiveNewsFeed.mock.funcGiveNewsFeed != nil {
		mmGiveNewsFeed.mock.t.Fatalf("FeedManagerMock.GiveNewsFeed mock is already set by Set")
	}

	if mmGiveNewsFeed.defaultExpectation == nil {
		mmGiveNewsFeed.defaultExpectation = &FeedManagerMockGiveNewsFeedExpectation{}
	}

	mmGiveNewsFeed.defaultExpectation.params = &FeedManagerMockGiveNewsFeedParams{ctx, userID}
	for _, e := range mmGiveNewsFeed.expectations {
		if minimock.Equal(e.params, mmGiveNewsFeed.defaultExpectation.params) {
			mmGiveNewsFeed.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGiveNewsFeed.defaultExpectation.params)
		}
	}

	return mmGiveNewsFeed
}

// Inspect accepts an inspector function that has same arguments as the FeedManager.GiveNewsFeed
func (mmGiveNewsFeed *mFeedManagerMockGiveNewsFeed) Inspect(f func(ctx context.Context, userID int)) *mFeedManagerMockGiveNewsFeed {
	if mmGiveNewsFeed.mock.inspectFuncGiveNewsFeed != nil {
		mmGiveNewsFeed.mock.t.Fatalf("Inspect function is already set for FeedManagerMock.GiveNewsFeed")
	}

	mmGiveNewsFeed.mock.inspectFuncGiveNewsFeed = f

	return mmGiveNewsFeed
}

// Return sets up results that will be returned by FeedManager.GiveNewsFeed
func (mmGiveNewsFeed *mFeedManagerMockGiveNewsFeed) Return(ta1 []entity.Tweet, err error) *FeedManagerMock {
	if mmGiveNewsFeed.mock.funcGiveNewsFeed != nil {
		mmGiveNewsFeed.mock.t.Fatalf("FeedManagerMock.GiveNewsFeed mock is already set by Set")
	}

	if mmGiveNewsFeed.defaultExpectation == nil {
		mmGiveNewsFeed.defaultExpectation = &FeedManagerMockGiveNewsFeedExpectation{mock: mmGiveNewsFeed.mock}
	}
	mmGiveNewsFeed.defaultExpectation.results = &FeedManagerMockGiveNewsFeedResults{ta1, err}
	return mmGiveNewsFeed.mock
}

//Set uses given function f to mock the FeedManager.GiveNewsFeed method
func (mmGiveNewsFeed *mFeedManagerMockGiveNewsFeed) Set(f func(ctx context.Context, userID int) (ta1 []entity.Tweet, err error)) *FeedManagerMock {
	if mmGiveNewsFeed.defaultExpectation != nil {
		mmGiveNewsFeed.mock.t.Fatalf("Default expectation is already set for the FeedManager.GiveNewsFeed method")
	}

	if len(mmGiveNewsFeed.expectations) > 0 {
		mmGiveNewsFeed.mock.t.Fatalf("Some expectations are already set for the FeedManager.GiveNewsFeed method")
	}

	mmGiveNewsFeed.mock.funcGiveNewsFeed = f
	return mmGiveNewsFeed.mock
}

// When sets expectation for the FeedManager.GiveNewsFeed which will trigger the result defined by the following
// Then helper
func (mmGiveNewsFeed *mFeedManagerMockGiveNewsFeed) When(ctx context.Context, userID int) *FeedManagerMockGiveNewsFeedExpectation {
	if mmGiveNewsFeed.mock.funcGiveNewsFeed != nil {
		mmGiveNewsFeed.mock.t.Fatalf("FeedManagerMock.GiveNewsFeed mock is already set by Set")
	}

	expectation := &FeedManagerMockGiveNewsFeedExpectation{
		mock:   mmGiveNewsFeed.mock,
		params: &FeedManagerMockGiveNewsFeedParams{ctx, userID},
	}
	mmGiveNewsFeed.expectations = append(mmGiveNewsFeed.expectations, expectation)
	return expectation
}

// Then sets up FeedManager.GiveNewsFeed return parameters for the expectation previously defined by the When method
func (e *FeedManagerMockGiveNewsFeedExpectation) Then(ta1 []entity.Tweet, err error) *FeedManagerMock {
	e.results = &FeedManagerMockGiveNewsFeedResults{ta1, err}
	return e.mock
}

// GiveNewsFeed implements usecase.FeedManager
func (mmGiveNewsFeed *FeedManagerMock) GiveNewsFeed(ctx context.Context, userID int) (ta1 []entity.Tweet, err error) {
	mm_atomic.AddUint64(&mmGiveNewsFeed.beforeGiveNewsFeedCounter, 1)
	defer mm_atomic.AddUint64(&mmGiveNewsFeed.afterGiveNewsFeedCounter, 1)

	if mmGiveNewsFeed.inspectFuncGiveNewsFeed != nil {
		mmGiveNewsFeed.inspectFuncGiveNewsFeed(ctx, userID)
	}

	mm_params := &FeedManagerMockGiveNewsFeedParams{ctx, userID}

	// Record call args
	mmGiveNewsFeed.GiveNewsFeedMock.mutex.Lock()
	mmGiveNewsFeed.GiveNewsFeedMock.callArgs = append(mmGiveNewsFeed.GiveNewsFeedMock.callArgs, mm_params)
	mmGiveNewsFeed.GiveNewsFeedMock.mutex.Unlock()

	for _, e := range mmGiveNewsFeed.GiveNewsFeedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ta1, e.results.err
		}
	}

	if mmGiveNewsFeed.GiveNewsFeedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGiveNewsFeed.GiveNewsFeedMock.defaultExpectation.Counter, 1)
		mm_want := mmGiveNewsFeed.GiveNewsFeedMock.defaultExpectation.params
		mm_got := FeedManagerMockGiveNewsFeedParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGiveNewsFeed.t.Errorf("FeedManagerMock.GiveNewsFeed got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGiveNewsFeed.GiveNewsFeedMock.defaultExpectation.results
		if mm_results == nil {
			mmGiveNewsFeed.t.Fatal("No results are set for the FeedManagerMock.GiveNewsFeed")
		}
		return (*mm_results).ta1, (*mm_results).err
	}
	if mmGiveNewsFeed.funcGiveNewsFeed != nil {
		return mmGiveNewsFeed.funcGiveNewsFeed(ctx, userID)
	}
	mmGiveNewsFeed.t.Fatalf("Unexpected call to FeedManagerMock.GiveNewsFeed. %v %v", ctx, userID)
	return
}

// GiveNewsFeedAfterCounter returns a count of finished FeedManagerMock.GiveNewsFeed invocations
func (mmGiveNewsFeed *FeedManagerMock) GiveNewsFeedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGiveNewsFeed.afterGiveNewsFeedCounter)
}

// GiveNewsFeedBeforeCounter returns a count of FeedManagerMock.GiveNewsFeed invocations
func (mmGiveNewsFeed *FeedManagerMock) GiveNewsFeedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGiveNewsFeed.beforeGiveNewsFeedCounter)
}

// Calls returns a list of arguments used in each call to FeedManagerMock.GiveNewsFeed.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGiveNewsFeed *mFeedManagerMockGiveNewsFeed) Calls() []*FeedManagerMockGiveNewsFeedParams {
	mmGiveNewsFeed.mutex.RLock()

	argCopy := make([]*FeedManagerMockGiveNewsFeedParams, len(mmGiveNewsFeed.callArgs))
	copy(argCopy, mmGiveNewsFeed.callArgs)

	mmGiveNewsFeed.mutex.RUnlock()

	return argCopy
}

// MinimockGiveNewsFeedDone returns true if the count of the GiveNewsFeed invocations corresponds
// the number of defined expectations
func (m *FeedManagerMock) MinimockGiveNewsFeedDone() bool {
	for _, e := range m.GiveNewsFeedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GiveNewsFeedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGiveNewsFeedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGiveNewsFeed != nil && mm_atomic.LoadUint64(&m.afterGiveNewsFeedCounter) < 1 {
		return false
	}
	return true
}

// MinimockGiveNewsFeedInspect logs each unmet expectation
func (m *FeedManagerMock) MinimockGiveNewsFeedInspect() {
	for _, e := range m.GiveNewsFeedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FeedManagerMock.GiveNewsFeed with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GiveNewsFeedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGiveNewsFeedCounter) < 1 {
		if m.GiveNewsFeedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FeedManagerMock.GiveNewsFeed")
		} else {
			m.t.Errorf("Expected call to FeedManagerMock.GiveNewsFeed with params: %#v", *m.GiveNewsFeedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGiveNewsFeed != nil && mm_atomic.LoadUint64(&m.afterGiveNewsFeedCounter) < 1 {
		m.t.Error("Expected call to FeedManagerMock.GiveNewsFeed")
	}
}

type mFeedManagerMockRemoveFollower struct {
	mock               *FeedManagerMock
	defaultExpectation *FeedManagerMockRemoveFollowerExpectation
	expectations       []*FeedManagerMockRemoveFollowerExpectation

	callArgs []*FeedManagerMockRemoveFollowerParams
	mutex    sync.RWMutex
}

// FeedManagerMockRemoveFollowerExpectation specifies expectation struct of the FeedManager.RemoveFollower
type FeedManagerMockRemoveFollowerExpectation struct {
	mock    *FeedManagerMock
	params  *FeedManagerMockRemoveFollowerParams
	results *FeedManagerMockRemoveFollowerResults
	Counter uint64
}

// FeedManagerMockRemoveFollowerParams contains parameters of the FeedManager.RemoveFollower
type FeedManagerMockRemoveFollowerParams struct {
	ctx        context.Context
	userID     int
	fromUserID int
}

// FeedManagerMockRemoveFollowerResults contains results of the FeedManager.RemoveFollower
type FeedManagerMockRemoveFollowerResults struct {
	err error
}

// Expect sets up expected params for FeedManager.RemoveFollower
func (mmRemoveFollower *mFeedManagerMockRemoveFollower) Expect(ctx context.Context, userID int, fromUserID int) *mFeedManagerMockRemoveFollower {
	if mmRemoveFollower.mock.funcRemoveFollower != nil {
		mmRemoveFollower.mock.t.Fatalf("FeedManagerMock.RemoveFollower mock is already set by Set")
	}

	if mmRemoveFollower.defaultExpectation == nil {
		mmRemoveFollower.defaultExpectation = &FeedManagerMockRemoveFollowerExpectation{}
	}

	mmRemoveFollower.defaultExpectation.params = &FeedManagerMockRemoveFollowerParams{ctx, userID, fromUserID}
	for _, e := range mmRemoveFollower.expectations {
		if minimock.Equal(e.params, mmRemoveFollower.defaultExpectation.params) {
			mmRemoveFollower.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveFollower.defaultExpectation.params)
		}
	}

	return mmRemoveFollower
}

// Inspect accepts an inspector function that has same arguments as the FeedManager.RemoveFollower
func (mmRemoveFollower *mFeedManagerMockRemoveFollower) Inspect(f func(ctx context.Context, userID int, fromUserID int)) *mFeedManagerMockRemoveFollower {
	if mmRemoveFollower.mock.inspectFuncRemoveFollower != nil {
		mmRemoveFollower.mock.t.Fatalf("Inspect function is already set for FeedManagerMock.RemoveFollower")
	}

	mmRemoveFollower.mock.inspectFuncRemoveFollower = f

	return mmRemoveFollower
}

// Return sets up results that will be returned by FeedManager.RemoveFollower
func (mmRemoveFollower *mFeedManagerMockRemoveFollower) Return(err error) *FeedManagerMock {
	if mmRemoveFollower.mock.funcRemoveFollower != nil {
		mmRemoveFollower.mock.t.Fatalf("FeedManagerMock.RemoveFollower mock is already set by Set")
	}

	if mmRemoveFollower.defaultExpectation == nil {
		mmRemoveFollower.defaultExpectation = &FeedManagerMockRemoveFollowerExpectation{mock: mmRemoveFollower.mock}
	}
	mmRemoveFollower.defaultExpectation.results = &FeedManagerMockRemoveFollowerResults{err}
	return mmRemoveFollower.mock
}

//Set uses given function f to mock the FeedManager.RemoveFollower method
func (mmRemoveFollower *mFeedManagerMockRemoveFollower) Set(f func(ctx context.Context, userID int, fromUserID int) (err error)) *FeedManagerMock {
	if mmRemoveFollower.defaultExpectation != nil {
		mmRemoveFollower.mock.t.Fatalf("Default expectation is already set for the FeedManager.RemoveFollower method")
	}

	if len(mmRemoveFollower.expectations) > 0 {
		mmRemoveFollower.mock.t.Fatalf("Some expectations are already set for the FeedManager.RemoveFollower method")
	}

	mmRemoveFollower.mock.funcRemoveFollower = f
	return mmRemoveFollower.mock
}

// When sets expectation for the FeedManager.RemoveFollower which will trigger the result defined by the following
// Then helper
func (mmRemoveFollower *mFeedManagerMockRemoveFollower) When(ctx context.Context, userID int, fromUserID int) *FeedManagerMockRemoveFollowerExpectation {
	if mmRemoveFollower.mock.funcRemoveFollower != nil {
		mmRemoveFollower.mock.t.Fatalf("FeedManagerMock.RemoveFollower mock is already set by Set")
	}

	expectation := &FeedManagerMockRemoveFollowerExpectation{
		mock:   mmRemoveFollower.mock,
		params: &FeedManagerMockRemoveFollowerParams{ctx, userID, fromUserID},
	}
	mmRemoveFollower.expectations = append(mmRemoveFollower.expectations, expectation)
	return expectation
}

// Then sets up FeedManager.RemoveFollower return parameters for the expectation previously defined by the When method
func (e *FeedManagerMockRemoveFollowerExpectation) Then(err error) *FeedManagerMock {
	e.results = &FeedManagerMockRemoveFollowerResults{err}
	return e.mock
}

// RemoveFollower implements usecase.FeedManager
func (mmRemoveFollower *FeedManagerMock) RemoveFollower(ctx context.Context, userID int, fromUserID int) (err error) {
	mm_atomic.AddUint64(&mmRemoveFollower.beforeRemoveFollowerCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveFollower.afterRemoveFollowerCounter, 1)

	if mmRemoveFollower.inspectFuncRemoveFollower != nil {
		mmRemoveFollower.inspectFuncRemoveFollower(ctx, userID, fromUserID)
	}

	mm_params := &FeedManagerMockRemoveFollowerParams{ctx, userID, fromUserID}

	// Record call args
	mmRemoveFollower.RemoveFollowerMock.mutex.Lock()
	mmRemoveFollower.RemoveFollowerMock.callArgs = append(mmRemoveFollower.RemoveFollowerMock.callArgs, mm_params)
	mmRemoveFollower.RemoveFollowerMock.mutex.Unlock()

	for _, e := range mmRemoveFollower.RemoveFollowerMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveFollower.RemoveFollowerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveFollower.RemoveFollowerMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveFollower.RemoveFollowerMock.defaultExpectation.params
		mm_got := FeedManagerMockRemoveFollowerParams{ctx, userID, fromUserID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveFollower.t.Errorf("FeedManagerMock.RemoveFollower got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveFollower.RemoveFollowerMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveFollower.t.Fatal("No results are set for the FeedManagerMock.RemoveFollower")
		}
		return (*mm_results).err
	}
	if mmRemoveFollower.funcRemoveFollower != nil {
		return mmRemoveFollower.funcRemoveFollower(ctx, userID, fromUserID)
	}
	mmRemoveFollower.t.Fatalf("Unexpected call to FeedManagerMock.RemoveFollower. %v %v %v", ctx, userID, fromUserID)
	return
}

// RemoveFollowerAfterCounter returns a count of finished FeedManagerMock.RemoveFollower invocations
func (mmRemoveFollower *FeedManagerMock) RemoveFollowerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveFollower.afterRemoveFollowerCounter)
}

// RemoveFollowerBeforeCounter returns a count of FeedManagerMock.RemoveFollower invocations
func (mmRemoveFollower *FeedManagerMock) RemoveFollowerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveFollower.beforeRemoveFollowerCounter)
}

// Calls returns a list of arguments used in each call to FeedManagerMock.RemoveFollower.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveFollower *mFeedManagerMockRemoveFollower) Calls() []*FeedManagerMockRemoveFollowerParams {
	mmRemoveFollower.mutex.RLock()

	argCopy := make([]*FeedManagerMockRemoveFollowerParams, len(mmRemoveFollower.callArgs))
	copy(argCopy, mmRemoveFollower.callArgs)

	mmRemoveFollower.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveFollowerDone returns true if the count of the RemoveFollower invocations corresponds
// the number of defined expectations
func (m *FeedManagerMock) MinimockRemoveFollowerDone() bool {
	for _, e := range m.RemoveFollowerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveFollowerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveFollowerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveFollower != nil && mm_atomic.LoadUint64(&m.afterRemoveFollowerCounter) < 1 {
		return false
	}
	return true
}

// MinimockRemoveFollowerInspect logs each unmet expectation
func (m *FeedManagerMock) MinimockRemoveFollowerInspect() {
	for _, e := range m.RemoveFollowerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FeedManagerMock.RemoveFollower with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveFollowerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveFollowerCounter) < 1 {
		if m.RemoveFollowerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FeedManagerMock.RemoveFollower")
		} else {
			m.t.Errorf("Expected call to FeedManagerMock.RemoveFollower with params: %#v", *m.RemoveFollowerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveFollower != nil && mm_atomic.LoadUint64(&m.afterRemoveFollowerCounter) < 1 {
		m.t.Error("Expected call to FeedManagerMock.RemoveFollower")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *FeedManagerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddFollowerInspect()

		m.MinimockAddNewTweetInspect()

		m.MinimockEditCommentInspect()

		m.MinimockEditTweetInspect()

		m.MinimockGiveNewsFeedInspect()

		m.MinimockRemoveFollowerInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *FeedManagerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *FeedManagerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddFollowerDone() &&
		m.MinimockAddNewTweetDone() &&
		m.MinimockEditCommentDone() &&
		m.MinimockEditTweetDone() &&
		m.MinimockGiveNewsFeedDone() &&
		m.MinimockRemoveFollowerDone()
}
