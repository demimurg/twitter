package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/demimurg/twitter/internal/usecase.FeedManager -o ./internal/usecase/mock/feed_manager.go -n FeedManagerMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/demimurg/twitter/internal/entity"
	"github.com/gojuno/minimock/v3"
)

// FeedManagerMock implements usecase.FeedManager
type FeedManagerMock struct {
	t minimock.Tester

	funcAddFollower          func(ctx context.Context, userID int, toUserID int) (err error)
	inspectFuncAddFollower   func(ctx context.Context, userID int, toUserID int)
	afterAddFollowerCounter  uint64
	beforeAddFollowerCounter uint64
	AddFollowerMock          mFeedManagerMockAddFollower

	funcAddTweet          func(ctx context.Context, userID int, text string) (err error)
	inspectFuncAddTweet   func(ctx context.Context, userID int, text string)
	afterAddTweetCounter  uint64
	beforeAddTweetCounter uint64
	AddTweetMock          mFeedManagerMockAddTweet

	funcEditComment          func(ctx context.Context, commentID int, text string) (err error)
	inspectFuncEditComment   func(ctx context.Context, commentID int, text string)
	afterEditCommentCounter  uint64
	beforeEditCommentCounter uint64
	EditCommentMock          mFeedManagerMockEditComment

	funcEditTweet          func(ctx context.Context, tweetID int, text string) (err error)
	inspectFuncEditTweet   func(ctx context.Context, tweetID int, text string)
	afterEditTweetCounter  uint64
	beforeEditTweetCounter uint64
	EditTweetMock          mFeedManagerMockEditTweet

	funcGetNewsFeed          func(ctx context.Context, userID int) (ta1 []entity.Tweet, err error)
	inspectFuncGetNewsFeed   func(ctx context.Context, userID int)
	afterGetNewsFeedCounter  uint64
	beforeGetNewsFeedCounter uint64
	GetNewsFeedMock          mFeedManagerMockGetNewsFeed

	funcGetRecommendedUsers          func(ctx context.Context, userID int) (ua1 []entity.User, err error)
	inspectFuncGetRecommendedUsers   func(ctx context.Context, userID int)
	afterGetRecommendedUsersCounter  uint64
	beforeGetRecommendedUsersCounter uint64
	GetRecommendedUsersMock          mFeedManagerMockGetRecommendedUsers

	funcRemoveFollower          func(ctx context.Context, userID int, fromUserID int) (err error)
	inspectFuncRemoveFollower   func(ctx context.Context, userID int, fromUserID int)
	afterRemoveFollowerCounter  uint64
	beforeRemoveFollowerCounter uint64
	RemoveFollowerMock          mFeedManagerMockRemoveFollower
}

// NewFeedManagerMock returns a mock for usecase.FeedManager
func NewFeedManagerMock(t minimock.Tester) *FeedManagerMock {
	m := &FeedManagerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddFollowerMock = mFeedManagerMockAddFollower{mock: m}
	m.AddFollowerMock.callArgs = []*FeedManagerMockAddFollowerParams{}

	m.AddTweetMock = mFeedManagerMockAddTweet{mock: m}
	m.AddTweetMock.callArgs = []*FeedManagerMockAddTweetParams{}

	m.EditCommentMock = mFeedManagerMockEditComment{mock: m}
	m.EditCommentMock.callArgs = []*FeedManagerMockEditCommentParams{}

	m.EditTweetMock = mFeedManagerMockEditTweet{mock: m}
	m.EditTweetMock.callArgs = []*FeedManagerMockEditTweetParams{}

	m.GetNewsFeedMock = mFeedManagerMockGetNewsFeed{mock: m}
	m.GetNewsFeedMock.callArgs = []*FeedManagerMockGetNewsFeedParams{}

	m.GetRecommendedUsersMock = mFeedManagerMockGetRecommendedUsers{mock: m}
	m.GetRecommendedUsersMock.callArgs = []*FeedManagerMockGetRecommendedUsersParams{}

	m.RemoveFollowerMock = mFeedManagerMockRemoveFollower{mock: m}
	m.RemoveFollowerMock.callArgs = []*FeedManagerMockRemoveFollowerParams{}

	return m
}

type mFeedManagerMockAddFollower struct {
	mock               *FeedManagerMock
	defaultExpectation *FeedManagerMockAddFollowerExpectation
	expectations       []*FeedManagerMockAddFollowerExpectation

	callArgs []*FeedManagerMockAddFollowerParams
	mutex    sync.RWMutex
}

// FeedManagerMockAddFollowerExpectation specifies expectation struct of the FeedManager.AddFollower
type FeedManagerMockAddFollowerExpectation struct {
	mock    *FeedManagerMock
	params  *FeedManagerMockAddFollowerParams
	results *FeedManagerMockAddFollowerResults
	Counter uint64
}

// FeedManagerMockAddFollowerParams contains parameters of the FeedManager.AddFollower
type FeedManagerMockAddFollowerParams struct {
	ctx      context.Context
	userID   int
	toUserID int
}

// FeedManagerMockAddFollowerResults contains results of the FeedManager.AddFollower
type FeedManagerMockAddFollowerResults struct {
	err error
}

// Expect sets up expected params for FeedManager.AddFollower
func (mmAddFollower *mFeedManagerMockAddFollower) Expect(ctx context.Context, userID int, toUserID int) *mFeedManagerMockAddFollower {
	if mmAddFollower.mock.funcAddFollower != nil {
		mmAddFollower.mock.t.Fatalf("FeedManagerMock.AddFollower mock is already set by Set")
	}

	if mmAddFollower.defaultExpectation == nil {
		mmAddFollower.defaultExpectation = &FeedManagerMockAddFollowerExpectation{}
	}

	mmAddFollower.defaultExpectation.params = &FeedManagerMockAddFollowerParams{ctx, userID, toUserID}
	for _, e := range mmAddFollower.expectations {
		if minimock.Equal(e.params, mmAddFollower.defaultExpectation.params) {
			mmAddFollower.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddFollower.defaultExpectation.params)
		}
	}

	return mmAddFollower
}

// Inspect accepts an inspector function that has same arguments as the FeedManager.AddFollower
func (mmAddFollower *mFeedManagerMockAddFollower) Inspect(f func(ctx context.Context, userID int, toUserID int)) *mFeedManagerMockAddFollower {
	if mmAddFollower.mock.inspectFuncAddFollower != nil {
		mmAddFollower.mock.t.Fatalf("Inspect function is already set for FeedManagerMock.AddFollower")
	}

	mmAddFollower.mock.inspectFuncAddFollower = f

	return mmAddFollower
}

// Return sets up results that will be returned by FeedManager.AddFollower
func (mmAddFollower *mFeedManagerMockAddFollower) Return(err error) *FeedManagerMock {
	if mmAddFollower.mock.funcAddFollower != nil {
		mmAddFollower.mock.t.Fatalf("FeedManagerMock.AddFollower mock is already set by Set")
	}

	if mmAddFollower.defaultExpectation == nil {
		mmAddFollower.defaultExpectation = &FeedManagerMockAddFollowerExpectation{mock: mmAddFollower.mock}
	}
	mmAddFollower.defaultExpectation.results = &FeedManagerMockAddFollowerResults{err}
	return mmAddFollower.mock
}

// Set uses given function f to mock the FeedManager.AddFollower method
func (mmAddFollower *mFeedManagerMockAddFollower) Set(f func(ctx context.Context, userID int, toUserID int) (err error)) *FeedManagerMock {
	if mmAddFollower.defaultExpectation != nil {
		mmAddFollower.mock.t.Fatalf("Default expectation is already set for the FeedManager.AddFollower method")
	}

	if len(mmAddFollower.expectations) > 0 {
		mmAddFollower.mock.t.Fatalf("Some expectations are already set for the FeedManager.AddFollower method")
	}

	mmAddFollower.mock.funcAddFollower = f
	return mmAddFollower.mock
}

// When sets expectation for the FeedManager.AddFollower which will trigger the result defined by the following
// Then helper
func (mmAddFollower *mFeedManagerMockAddFollower) When(ctx context.Context, userID int, toUserID int) *FeedManagerMockAddFollowerExpectation {
	if mmAddFollower.mock.funcAddFollower != nil {
		mmAddFollower.mock.t.Fatalf("FeedManagerMock.AddFollower mock is already set by Set")
	}

	expectation := &FeedManagerMockAddFollowerExpectation{
		mock:   mmAddFollower.mock,
		params: &FeedManagerMockAddFollowerParams{ctx, userID, toUserID},
	}
	mmAddFollower.expectations = append(mmAddFollower.expectations, expectation)
	return expectation
}

// Then sets up FeedManager.AddFollower return parameters for the expectation previously defined by the When method
func (e *FeedManagerMockAddFollowerExpectation) Then(err error) *FeedManagerMock {
	e.results = &FeedManagerMockAddFollowerResults{err}
	return e.mock
}

// AddFollower implements usecase.FeedManager
func (mmAddFollower *FeedManagerMock) AddFollower(ctx context.Context, userID int, toUserID int) (err error) {
	mm_atomic.AddUint64(&mmAddFollower.beforeAddFollowerCounter, 1)
	defer mm_atomic.AddUint64(&mmAddFollower.afterAddFollowerCounter, 1)

	if mmAddFollower.inspectFuncAddFollower != nil {
		mmAddFollower.inspectFuncAddFollower(ctx, userID, toUserID)
	}

	mm_params := &FeedManagerMockAddFollowerParams{ctx, userID, toUserID}

	// Record call args
	mmAddFollower.AddFollowerMock.mutex.Lock()
	mmAddFollower.AddFollowerMock.callArgs = append(mmAddFollower.AddFollowerMock.callArgs, mm_params)
	mmAddFollower.AddFollowerMock.mutex.Unlock()

	for _, e := range mmAddFollower.AddFollowerMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddFollower.AddFollowerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddFollower.AddFollowerMock.defaultExpectation.Counter, 1)
		mm_want := mmAddFollower.AddFollowerMock.defaultExpectation.params
		mm_got := FeedManagerMockAddFollowerParams{ctx, userID, toUserID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddFollower.t.Errorf("FeedManagerMock.AddFollower got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddFollower.AddFollowerMock.defaultExpectation.results
		if mm_results == nil {
			mmAddFollower.t.Fatal("No results are set for the FeedManagerMock.AddFollower")
		}
		return (*mm_results).err
	}
	if mmAddFollower.funcAddFollower != nil {
		return mmAddFollower.funcAddFollower(ctx, userID, toUserID)
	}
	mmAddFollower.t.Fatalf("Unexpected call to FeedManagerMock.AddFollower. %v %v %v", ctx, userID, toUserID)
	return
}

// AddFollowerAfterCounter returns a count of finished FeedManagerMock.AddFollower invocations
func (mmAddFollower *FeedManagerMock) AddFollowerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddFollower.afterAddFollowerCounter)
}

// AddFollowerBeforeCounter returns a count of FeedManagerMock.AddFollower invocations
func (mmAddFollower *FeedManagerMock) AddFollowerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddFollower.beforeAddFollowerCounter)
}

// Calls returns a list of arguments used in each call to FeedManagerMock.AddFollower.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddFollower *mFeedManagerMockAddFollower) Calls() []*FeedManagerMockAddFollowerParams {
	mmAddFollower.mutex.RLock()

	argCopy := make([]*FeedManagerMockAddFollowerParams, len(mmAddFollower.callArgs))
	copy(argCopy, mmAddFollower.callArgs)

	mmAddFollower.mutex.RUnlock()

	return argCopy
}

// MinimockAddFollowerDone returns true if the count of the AddFollower invocations corresponds
// the number of defined expectations
func (m *FeedManagerMock) MinimockAddFollowerDone() bool {
	for _, e := range m.AddFollowerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddFollowerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddFollowerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddFollower != nil && mm_atomic.LoadUint64(&m.afterAddFollowerCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddFollowerInspect logs each unmet expectation
func (m *FeedManagerMock) MinimockAddFollowerInspect() {
	for _, e := range m.AddFollowerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FeedManagerMock.AddFollower with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddFollowerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddFollowerCounter) < 1 {
		if m.AddFollowerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FeedManagerMock.AddFollower")
		} else {
			m.t.Errorf("Expected call to FeedManagerMock.AddFollower with params: %#v", *m.AddFollowerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddFollower != nil && mm_atomic.LoadUint64(&m.afterAddFollowerCounter) < 1 {
		m.t.Error("Expected call to FeedManagerMock.AddFollower")
	}
}

type mFeedManagerMockAddTweet struct {
	mock               *FeedManagerMock
	defaultExpectation *FeedManagerMockAddTweetExpectation
	expectations       []*FeedManagerMockAddTweetExpectation

	callArgs []*FeedManagerMockAddTweetParams
	mutex    sync.RWMutex
}

// FeedManagerMockAddTweetExpectation specifies expectation struct of the FeedManager.AddTweet
type FeedManagerMockAddTweetExpectation struct {
	mock    *FeedManagerMock
	params  *FeedManagerMockAddTweetParams
	results *FeedManagerMockAddTweetResults
	Counter uint64
}

// FeedManagerMockAddTweetParams contains parameters of the FeedManager.AddTweet
type FeedManagerMockAddTweetParams struct {
	ctx    context.Context
	userID int
	text   string
}

// FeedManagerMockAddTweetResults contains results of the FeedManager.AddTweet
type FeedManagerMockAddTweetResults struct {
	err error
}

// Expect sets up expected params for FeedManager.AddTweet
func (mmAddTweet *mFeedManagerMockAddTweet) Expect(ctx context.Context, userID int, text string) *mFeedManagerMockAddTweet {
	if mmAddTweet.mock.funcAddTweet != nil {
		mmAddTweet.mock.t.Fatalf("FeedManagerMock.AddTweet mock is already set by Set")
	}

	if mmAddTweet.defaultExpectation == nil {
		mmAddTweet.defaultExpectation = &FeedManagerMockAddTweetExpectation{}
	}

	mmAddTweet.defaultExpectation.params = &FeedManagerMockAddTweetParams{ctx, userID, text}
	for _, e := range mmAddTweet.expectations {
		if minimock.Equal(e.params, mmAddTweet.defaultExpectation.params) {
			mmAddTweet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddTweet.defaultExpectation.params)
		}
	}

	return mmAddTweet
}

// Inspect accepts an inspector function that has same arguments as the FeedManager.AddTweet
func (mmAddTweet *mFeedManagerMockAddTweet) Inspect(f func(ctx context.Context, userID int, text string)) *mFeedManagerMockAddTweet {
	if mmAddTweet.mock.inspectFuncAddTweet != nil {
		mmAddTweet.mock.t.Fatalf("Inspect function is already set for FeedManagerMock.AddTweet")
	}

	mmAddTweet.mock.inspectFuncAddTweet = f

	return mmAddTweet
}

// Return sets up results that will be returned by FeedManager.AddTweet
func (mmAddTweet *mFeedManagerMockAddTweet) Return(err error) *FeedManagerMock {
	if mmAddTweet.mock.funcAddTweet != nil {
		mmAddTweet.mock.t.Fatalf("FeedManagerMock.AddTweet mock is already set by Set")
	}

	if mmAddTweet.defaultExpectation == nil {
		mmAddTweet.defaultExpectation = &FeedManagerMockAddTweetExpectation{mock: mmAddTweet.mock}
	}
	mmAddTweet.defaultExpectation.results = &FeedManagerMockAddTweetResults{err}
	return mmAddTweet.mock
}

// Set uses given function f to mock the FeedManager.AddTweet method
func (mmAddTweet *mFeedManagerMockAddTweet) Set(f func(ctx context.Context, userID int, text string) (err error)) *FeedManagerMock {
	if mmAddTweet.defaultExpectation != nil {
		mmAddTweet.mock.t.Fatalf("Default expectation is already set for the FeedManager.AddTweet method")
	}

	if len(mmAddTweet.expectations) > 0 {
		mmAddTweet.mock.t.Fatalf("Some expectations are already set for the FeedManager.AddTweet method")
	}

	mmAddTweet.mock.funcAddTweet = f
	return mmAddTweet.mock
}

// When sets expectation for the FeedManager.AddTweet which will trigger the result defined by the following
// Then helper
func (mmAddTweet *mFeedManagerMockAddTweet) When(ctx context.Context, userID int, text string) *FeedManagerMockAddTweetExpectation {
	if mmAddTweet.mock.funcAddTweet != nil {
		mmAddTweet.mock.t.Fatalf("FeedManagerMock.AddTweet mock is already set by Set")
	}

	expectation := &FeedManagerMockAddTweetExpectation{
		mock:   mmAddTweet.mock,
		params: &FeedManagerMockAddTweetParams{ctx, userID, text},
	}
	mmAddTweet.expectations = append(mmAddTweet.expectations, expectation)
	return expectation
}

// Then sets up FeedManager.AddTweet return parameters for the expectation previously defined by the When method
func (e *FeedManagerMockAddTweetExpectation) Then(err error) *FeedManagerMock {
	e.results = &FeedManagerMockAddTweetResults{err}
	return e.mock
}

// AddTweet implements usecase.FeedManager
func (mmAddTweet *FeedManagerMock) AddTweet(ctx context.Context, userID int, text string) (err error) {
	mm_atomic.AddUint64(&mmAddTweet.beforeAddTweetCounter, 1)
	defer mm_atomic.AddUint64(&mmAddTweet.afterAddTweetCounter, 1)

	if mmAddTweet.inspectFuncAddTweet != nil {
		mmAddTweet.inspectFuncAddTweet(ctx, userID, text)
	}

	mm_params := &FeedManagerMockAddTweetParams{ctx, userID, text}

	// Record call args
	mmAddTweet.AddTweetMock.mutex.Lock()
	mmAddTweet.AddTweetMock.callArgs = append(mmAddTweet.AddTweetMock.callArgs, mm_params)
	mmAddTweet.AddTweetMock.mutex.Unlock()

	for _, e := range mmAddTweet.AddTweetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddTweet.AddTweetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddTweet.AddTweetMock.defaultExpectation.Counter, 1)
		mm_want := mmAddTweet.AddTweetMock.defaultExpectation.params
		mm_got := FeedManagerMockAddTweetParams{ctx, userID, text}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddTweet.t.Errorf("FeedManagerMock.AddTweet got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddTweet.AddTweetMock.defaultExpectation.results
		if mm_results == nil {
			mmAddTweet.t.Fatal("No results are set for the FeedManagerMock.AddTweet")
		}
		return (*mm_results).err
	}
	if mmAddTweet.funcAddTweet != nil {
		return mmAddTweet.funcAddTweet(ctx, userID, text)
	}
	mmAddTweet.t.Fatalf("Unexpected call to FeedManagerMock.AddTweet. %v %v %v", ctx, userID, text)
	return
}

// AddTweetAfterCounter returns a count of finished FeedManagerMock.AddTweet invocations
func (mmAddTweet *FeedManagerMock) AddTweetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddTweet.afterAddTweetCounter)
}

// AddTweetBeforeCounter returns a count of FeedManagerMock.AddTweet invocations
func (mmAddTweet *FeedManagerMock) AddTweetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddTweet.beforeAddTweetCounter)
}

// Calls returns a list of arguments used in each call to FeedManagerMock.AddTweet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddTweet *mFeedManagerMockAddTweet) Calls() []*FeedManagerMockAddTweetParams {
	mmAddTweet.mutex.RLock()

	argCopy := make([]*FeedManagerMockAddTweetParams, len(mmAddTweet.callArgs))
	copy(argCopy, mmAddTweet.callArgs)

	mmAddTweet.mutex.RUnlock()

	return argCopy
}

// MinimockAddTweetDone returns true if the count of the AddTweet invocations corresponds
// the number of defined expectations
func (m *FeedManagerMock) MinimockAddTweetDone() bool {
	for _, e := range m.AddTweetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddTweetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddTweetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddTweet != nil && mm_atomic.LoadUint64(&m.afterAddTweetCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddTweetInspect logs each unmet expectation
func (m *FeedManagerMock) MinimockAddTweetInspect() {
	for _, e := range m.AddTweetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FeedManagerMock.AddTweet with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddTweetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddTweetCounter) < 1 {
		if m.AddTweetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FeedManagerMock.AddTweet")
		} else {
			m.t.Errorf("Expected call to FeedManagerMock.AddTweet with params: %#v", *m.AddTweetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddTweet != nil && mm_atomic.LoadUint64(&m.afterAddTweetCounter) < 1 {
		m.t.Error("Expected call to FeedManagerMock.AddTweet")
	}
}

type mFeedManagerMockEditComment struct {
	mock               *FeedManagerMock
	defaultExpectation *FeedManagerMockEditCommentExpectation
	expectations       []*FeedManagerMockEditCommentExpectation

	callArgs []*FeedManagerMockEditCommentParams
	mutex    sync.RWMutex
}

// FeedManagerMockEditCommentExpectation specifies expectation struct of the FeedManager.EditComment
type FeedManagerMockEditCommentExpectation struct {
	mock    *FeedManagerMock
	params  *FeedManagerMockEditCommentParams
	results *FeedManagerMockEditCommentResults
	Counter uint64
}

// FeedManagerMockEditCommentParams contains parameters of the FeedManager.EditComment
type FeedManagerMockEditCommentParams struct {
	ctx       context.Context
	commentID int
	text      string
}

// FeedManagerMockEditCommentResults contains results of the FeedManager.EditComment
type FeedManagerMockEditCommentResults struct {
	err error
}

// Expect sets up expected params for FeedManager.EditComment
func (mmEditComment *mFeedManagerMockEditComment) Expect(ctx context.Context, commentID int, text string) *mFeedManagerMockEditComment {
	if mmEditComment.mock.funcEditComment != nil {
		mmEditComment.mock.t.Fatalf("FeedManagerMock.EditComment mock is already set by Set")
	}

	if mmEditComment.defaultExpectation == nil {
		mmEditComment.defaultExpectation = &FeedManagerMockEditCommentExpectation{}
	}

	mmEditComment.defaultExpectation.params = &FeedManagerMockEditCommentParams{ctx, commentID, text}
	for _, e := range mmEditComment.expectations {
		if minimock.Equal(e.params, mmEditComment.defaultExpectation.params) {
			mmEditComment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEditComment.defaultExpectation.params)
		}
	}

	return mmEditComment
}

// Inspect accepts an inspector function that has same arguments as the FeedManager.EditComment
func (mmEditComment *mFeedManagerMockEditComment) Inspect(f func(ctx context.Context, commentID int, text string)) *mFeedManagerMockEditComment {
	if mmEditComment.mock.inspectFuncEditComment != nil {
		mmEditComment.mock.t.Fatalf("Inspect function is already set for FeedManagerMock.EditComment")
	}

	mmEditComment.mock.inspectFuncEditComment = f

	return mmEditComment
}

// Return sets up results that will be returned by FeedManager.EditComment
func (mmEditComment *mFeedManagerMockEditComment) Return(err error) *FeedManagerMock {
	if mmEditComment.mock.funcEditComment != nil {
		mmEditComment.mock.t.Fatalf("FeedManagerMock.EditComment mock is already set by Set")
	}

	if mmEditComment.defaultExpectation == nil {
		mmEditComment.defaultExpectation = &FeedManagerMockEditCommentExpectation{mock: mmEditComment.mock}
	}
	mmEditComment.defaultExpectation.results = &FeedManagerMockEditCommentResults{err}
	return mmEditComment.mock
}

// Set uses given function f to mock the FeedManager.EditComment method
func (mmEditComment *mFeedManagerMockEditComment) Set(f func(ctx context.Context, commentID int, text string) (err error)) *FeedManagerMock {
	if mmEditComment.defaultExpectation != nil {
		mmEditComment.mock.t.Fatalf("Default expectation is already set for the FeedManager.EditComment method")
	}

	if len(mmEditComment.expectations) > 0 {
		mmEditComment.mock.t.Fatalf("Some expectations are already set for the FeedManager.EditComment method")
	}

	mmEditComment.mock.funcEditComment = f
	return mmEditComment.mock
}

// When sets expectation for the FeedManager.EditComment which will trigger the result defined by the following
// Then helper
func (mmEditComment *mFeedManagerMockEditComment) When(ctx context.Context, commentID int, text string) *FeedManagerMockEditCommentExpectation {
	if mmEditComment.mock.funcEditComment != nil {
		mmEditComment.mock.t.Fatalf("FeedManagerMock.EditComment mock is already set by Set")
	}

	expectation := &FeedManagerMockEditCommentExpectation{
		mock:   mmEditComment.mock,
		params: &FeedManagerMockEditCommentParams{ctx, commentID, text},
	}
	mmEditComment.expectations = append(mmEditComment.expectations, expectation)
	return expectation
}

// Then sets up FeedManager.EditComment return parameters for the expectation previously defined by the When method
func (e *FeedManagerMockEditCommentExpectation) Then(err error) *FeedManagerMock {
	e.results = &FeedManagerMockEditCommentResults{err}
	return e.mock
}

// EditComment implements usecase.FeedManager
func (mmEditComment *FeedManagerMock) EditComment(ctx context.Context, commentID int, text string) (err error) {
	mm_atomic.AddUint64(&mmEditComment.beforeEditCommentCounter, 1)
	defer mm_atomic.AddUint64(&mmEditComment.afterEditCommentCounter, 1)

	if mmEditComment.inspectFuncEditComment != nil {
		mmEditComment.inspectFuncEditComment(ctx, commentID, text)
	}

	mm_params := &FeedManagerMockEditCommentParams{ctx, commentID, text}

	// Record call args
	mmEditComment.EditCommentMock.mutex.Lock()
	mmEditComment.EditCommentMock.callArgs = append(mmEditComment.EditCommentMock.callArgs, mm_params)
	mmEditComment.EditCommentMock.mutex.Unlock()

	for _, e := range mmEditComment.EditCommentMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmEditComment.EditCommentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEditComment.EditCommentMock.defaultExpectation.Counter, 1)
		mm_want := mmEditComment.EditCommentMock.defaultExpectation.params
		mm_got := FeedManagerMockEditCommentParams{ctx, commentID, text}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEditComment.t.Errorf("FeedManagerMock.EditComment got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEditComment.EditCommentMock.defaultExpectation.results
		if mm_results == nil {
			mmEditComment.t.Fatal("No results are set for the FeedManagerMock.EditComment")
		}
		return (*mm_results).err
	}
	if mmEditComment.funcEditComment != nil {
		return mmEditComment.funcEditComment(ctx, commentID, text)
	}
	mmEditComment.t.Fatalf("Unexpected call to FeedManagerMock.EditComment. %v %v %v", ctx, commentID, text)
	return
}

// EditCommentAfterCounter returns a count of finished FeedManagerMock.EditComment invocations
func (mmEditComment *FeedManagerMock) EditCommentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEditComment.afterEditCommentCounter)
}

// EditCommentBeforeCounter returns a count of FeedManagerMock.EditComment invocations
func (mmEditComment *FeedManagerMock) EditCommentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEditComment.beforeEditCommentCounter)
}

// Calls returns a list of arguments used in each call to FeedManagerMock.EditComment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEditComment *mFeedManagerMockEditComment) Calls() []*FeedManagerMockEditCommentParams {
	mmEditComment.mutex.RLock()

	argCopy := make([]*FeedManagerMockEditCommentParams, len(mmEditComment.callArgs))
	copy(argCopy, mmEditComment.callArgs)

	mmEditComment.mutex.RUnlock()

	return argCopy
}

// MinimockEditCommentDone returns true if the count of the EditComment invocations corresponds
// the number of defined expectations
func (m *FeedManagerMock) MinimockEditCommentDone() bool {
	for _, e := range m.EditCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EditCommentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEditCommentCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEditComment != nil && mm_atomic.LoadUint64(&m.afterEditCommentCounter) < 1 {
		return false
	}
	return true
}

// MinimockEditCommentInspect logs each unmet expectation
func (m *FeedManagerMock) MinimockEditCommentInspect() {
	for _, e := range m.EditCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FeedManagerMock.EditComment with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EditCommentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEditCommentCounter) < 1 {
		if m.EditCommentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FeedManagerMock.EditComment")
		} else {
			m.t.Errorf("Expected call to FeedManagerMock.EditComment with params: %#v", *m.EditCommentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEditComment != nil && mm_atomic.LoadUint64(&m.afterEditCommentCounter) < 1 {
		m.t.Error("Expected call to FeedManagerMock.EditComment")
	}
}

type mFeedManagerMockEditTweet struct {
	mock               *FeedManagerMock
	defaultExpectation *FeedManagerMockEditTweetExpectation
	expectations       []*FeedManagerMockEditTweetExpectation

	callArgs []*FeedManagerMockEditTweetParams
	mutex    sync.RWMutex
}

// FeedManagerMockEditTweetExpectation specifies expectation struct of the FeedManager.EditTweet
type FeedManagerMockEditTweetExpectation struct {
	mock    *FeedManagerMock
	params  *FeedManagerMockEditTweetParams
	results *FeedManagerMockEditTweetResults
	Counter uint64
}

// FeedManagerMockEditTweetParams contains parameters of the FeedManager.EditTweet
type FeedManagerMockEditTweetParams struct {
	ctx     context.Context
	tweetID int
	text    string
}

// FeedManagerMockEditTweetResults contains results of the FeedManager.EditTweet
type FeedManagerMockEditTweetResults struct {
	err error
}

// Expect sets up expected params for FeedManager.EditTweet
func (mmEditTweet *mFeedManagerMockEditTweet) Expect(ctx context.Context, tweetID int, text string) *mFeedManagerMockEditTweet {
	if mmEditTweet.mock.funcEditTweet != nil {
		mmEditTweet.mock.t.Fatalf("FeedManagerMock.EditTweet mock is already set by Set")
	}

	if mmEditTweet.defaultExpectation == nil {
		mmEditTweet.defaultExpectation = &FeedManagerMockEditTweetExpectation{}
	}

	mmEditTweet.defaultExpectation.params = &FeedManagerMockEditTweetParams{ctx, tweetID, text}
	for _, e := range mmEditTweet.expectations {
		if minimock.Equal(e.params, mmEditTweet.defaultExpectation.params) {
			mmEditTweet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEditTweet.defaultExpectation.params)
		}
	}

	return mmEditTweet
}

// Inspect accepts an inspector function that has same arguments as the FeedManager.EditTweet
func (mmEditTweet *mFeedManagerMockEditTweet) Inspect(f func(ctx context.Context, tweetID int, text string)) *mFeedManagerMockEditTweet {
	if mmEditTweet.mock.inspectFuncEditTweet != nil {
		mmEditTweet.mock.t.Fatalf("Inspect function is already set for FeedManagerMock.EditTweet")
	}

	mmEditTweet.mock.inspectFuncEditTweet = f

	return mmEditTweet
}

// Return sets up results that will be returned by FeedManager.EditTweet
func (mmEditTweet *mFeedManagerMockEditTweet) Return(err error) *FeedManagerMock {
	if mmEditTweet.mock.funcEditTweet != nil {
		mmEditTweet.mock.t.Fatalf("FeedManagerMock.EditTweet mock is already set by Set")
	}

	if mmEditTweet.defaultExpectation == nil {
		mmEditTweet.defaultExpectation = &FeedManagerMockEditTweetExpectation{mock: mmEditTweet.mock}
	}
	mmEditTweet.defaultExpectation.results = &FeedManagerMockEditTweetResults{err}
	return mmEditTweet.mock
}

// Set uses given function f to mock the FeedManager.EditTweet method
func (mmEditTweet *mFeedManagerMockEditTweet) Set(f func(ctx context.Context, tweetID int, text string) (err error)) *FeedManagerMock {
	if mmEditTweet.defaultExpectation != nil {
		mmEditTweet.mock.t.Fatalf("Default expectation is already set for the FeedManager.EditTweet method")
	}

	if len(mmEditTweet.expectations) > 0 {
		mmEditTweet.mock.t.Fatalf("Some expectations are already set for the FeedManager.EditTweet method")
	}

	mmEditTweet.mock.funcEditTweet = f
	return mmEditTweet.mock
}

// When sets expectation for the FeedManager.EditTweet which will trigger the result defined by the following
// Then helper
func (mmEditTweet *mFeedManagerMockEditTweet) When(ctx context.Context, tweetID int, text string) *FeedManagerMockEditTweetExpectation {
	if mmEditTweet.mock.funcEditTweet != nil {
		mmEditTweet.mock.t.Fatalf("FeedManagerMock.EditTweet mock is already set by Set")
	}

	expectation := &FeedManagerMockEditTweetExpectation{
		mock:   mmEditTweet.mock,
		params: &FeedManagerMockEditTweetParams{ctx, tweetID, text},
	}
	mmEditTweet.expectations = append(mmEditTweet.expectations, expectation)
	return expectation
}

// Then sets up FeedManager.EditTweet return parameters for the expectation previously defined by the When method
func (e *FeedManagerMockEditTweetExpectation) Then(err error) *FeedManagerMock {
	e.results = &FeedManagerMockEditTweetResults{err}
	return e.mock
}

// EditTweet implements usecase.FeedManager
func (mmEditTweet *FeedManagerMock) EditTweet(ctx context.Context, tweetID int, text string) (err error) {
	mm_atomic.AddUint64(&mmEditTweet.beforeEditTweetCounter, 1)
	defer mm_atomic.AddUint64(&mmEditTweet.afterEditTweetCounter, 1)

	if mmEditTweet.inspectFuncEditTweet != nil {
		mmEditTweet.inspectFuncEditTweet(ctx, tweetID, text)
	}

	mm_params := &FeedManagerMockEditTweetParams{ctx, tweetID, text}

	// Record call args
	mmEditTweet.EditTweetMock.mutex.Lock()
	mmEditTweet.EditTweetMock.callArgs = append(mmEditTweet.EditTweetMock.callArgs, mm_params)
	mmEditTweet.EditTweetMock.mutex.Unlock()

	for _, e := range mmEditTweet.EditTweetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmEditTweet.EditTweetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEditTweet.EditTweetMock.defaultExpectation.Counter, 1)
		mm_want := mmEditTweet.EditTweetMock.defaultExpectation.params
		mm_got := FeedManagerMockEditTweetParams{ctx, tweetID, text}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEditTweet.t.Errorf("FeedManagerMock.EditTweet got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEditTweet.EditTweetMock.defaultExpectation.results
		if mm_results == nil {
			mmEditTweet.t.Fatal("No results are set for the FeedManagerMock.EditTweet")
		}
		return (*mm_results).err
	}
	if mmEditTweet.funcEditTweet != nil {
		return mmEditTweet.funcEditTweet(ctx, tweetID, text)
	}
	mmEditTweet.t.Fatalf("Unexpected call to FeedManagerMock.EditTweet. %v %v %v", ctx, tweetID, text)
	return
}

// EditTweetAfterCounter returns a count of finished FeedManagerMock.EditTweet invocations
func (mmEditTweet *FeedManagerMock) EditTweetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEditTweet.afterEditTweetCounter)
}

// EditTweetBeforeCounter returns a count of FeedManagerMock.EditTweet invocations
func (mmEditTweet *FeedManagerMock) EditTweetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEditTweet.beforeEditTweetCounter)
}

// Calls returns a list of arguments used in each call to FeedManagerMock.EditTweet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEditTweet *mFeedManagerMockEditTweet) Calls() []*FeedManagerMockEditTweetParams {
	mmEditTweet.mutex.RLock()

	argCopy := make([]*FeedManagerMockEditTweetParams, len(mmEditTweet.callArgs))
	copy(argCopy, mmEditTweet.callArgs)

	mmEditTweet.mutex.RUnlock()

	return argCopy
}

// MinimockEditTweetDone returns true if the count of the EditTweet invocations corresponds
// the number of defined expectations
func (m *FeedManagerMock) MinimockEditTweetDone() bool {
	for _, e := range m.EditTweetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EditTweetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEditTweetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEditTweet != nil && mm_atomic.LoadUint64(&m.afterEditTweetCounter) < 1 {
		return false
	}
	return true
}

// MinimockEditTweetInspect logs each unmet expectation
func (m *FeedManagerMock) MinimockEditTweetInspect() {
	for _, e := range m.EditTweetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FeedManagerMock.EditTweet with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EditTweetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEditTweetCounter) < 1 {
		if m.EditTweetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FeedManagerMock.EditTweet")
		} else {
			m.t.Errorf("Expected call to FeedManagerMock.EditTweet with params: %#v", *m.EditTweetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEditTweet != nil && mm_atomic.LoadUint64(&m.afterEditTweetCounter) < 1 {
		m.t.Error("Expected call to FeedManagerMock.EditTweet")
	}
}

type mFeedManagerMockGetNewsFeed struct {
	mock               *FeedManagerMock
	defaultExpectation *FeedManagerMockGetNewsFeedExpectation
	expectations       []*FeedManagerMockGetNewsFeedExpectation

	callArgs []*FeedManagerMockGetNewsFeedParams
	mutex    sync.RWMutex
}

// FeedManagerMockGetNewsFeedExpectation specifies expectation struct of the FeedManager.GetNewsFeed
type FeedManagerMockGetNewsFeedExpectation struct {
	mock    *FeedManagerMock
	params  *FeedManagerMockGetNewsFeedParams
	results *FeedManagerMockGetNewsFeedResults
	Counter uint64
}

// FeedManagerMockGetNewsFeedParams contains parameters of the FeedManager.GetNewsFeed
type FeedManagerMockGetNewsFeedParams struct {
	ctx    context.Context
	userID int
}

// FeedManagerMockGetNewsFeedResults contains results of the FeedManager.GetNewsFeed
type FeedManagerMockGetNewsFeedResults struct {
	ta1 []entity.Tweet
	err error
}

// Expect sets up expected params for FeedManager.GetNewsFeed
func (mmGetNewsFeed *mFeedManagerMockGetNewsFeed) Expect(ctx context.Context, userID int) *mFeedManagerMockGetNewsFeed {
	if mmGetNewsFeed.mock.funcGetNewsFeed != nil {
		mmGetNewsFeed.mock.t.Fatalf("FeedManagerMock.GetNewsFeed mock is already set by Set")
	}

	if mmGetNewsFeed.defaultExpectation == nil {
		mmGetNewsFeed.defaultExpectation = &FeedManagerMockGetNewsFeedExpectation{}
	}

	mmGetNewsFeed.defaultExpectation.params = &FeedManagerMockGetNewsFeedParams{ctx, userID}
	for _, e := range mmGetNewsFeed.expectations {
		if minimock.Equal(e.params, mmGetNewsFeed.defaultExpectation.params) {
			mmGetNewsFeed.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetNewsFeed.defaultExpectation.params)
		}
	}

	return mmGetNewsFeed
}

// Inspect accepts an inspector function that has same arguments as the FeedManager.GetNewsFeed
func (mmGetNewsFeed *mFeedManagerMockGetNewsFeed) Inspect(f func(ctx context.Context, userID int)) *mFeedManagerMockGetNewsFeed {
	if mmGetNewsFeed.mock.inspectFuncGetNewsFeed != nil {
		mmGetNewsFeed.mock.t.Fatalf("Inspect function is already set for FeedManagerMock.GetNewsFeed")
	}

	mmGetNewsFeed.mock.inspectFuncGetNewsFeed = f

	return mmGetNewsFeed
}

// Return sets up results that will be returned by FeedManager.GetNewsFeed
func (mmGetNewsFeed *mFeedManagerMockGetNewsFeed) Return(ta1 []entity.Tweet, err error) *FeedManagerMock {
	if mmGetNewsFeed.mock.funcGetNewsFeed != nil {
		mmGetNewsFeed.mock.t.Fatalf("FeedManagerMock.GetNewsFeed mock is already set by Set")
	}

	if mmGetNewsFeed.defaultExpectation == nil {
		mmGetNewsFeed.defaultExpectation = &FeedManagerMockGetNewsFeedExpectation{mock: mmGetNewsFeed.mock}
	}
	mmGetNewsFeed.defaultExpectation.results = &FeedManagerMockGetNewsFeedResults{ta1, err}
	return mmGetNewsFeed.mock
}

// Set uses given function f to mock the FeedManager.GetNewsFeed method
func (mmGetNewsFeed *mFeedManagerMockGetNewsFeed) Set(f func(ctx context.Context, userID int) (ta1 []entity.Tweet, err error)) *FeedManagerMock {
	if mmGetNewsFeed.defaultExpectation != nil {
		mmGetNewsFeed.mock.t.Fatalf("Default expectation is already set for the FeedManager.GetNewsFeed method")
	}

	if len(mmGetNewsFeed.expectations) > 0 {
		mmGetNewsFeed.mock.t.Fatalf("Some expectations are already set for the FeedManager.GetNewsFeed method")
	}

	mmGetNewsFeed.mock.funcGetNewsFeed = f
	return mmGetNewsFeed.mock
}

// When sets expectation for the FeedManager.GetNewsFeed which will trigger the result defined by the following
// Then helper
func (mmGetNewsFeed *mFeedManagerMockGetNewsFeed) When(ctx context.Context, userID int) *FeedManagerMockGetNewsFeedExpectation {
	if mmGetNewsFeed.mock.funcGetNewsFeed != nil {
		mmGetNewsFeed.mock.t.Fatalf("FeedManagerMock.GetNewsFeed mock is already set by Set")
	}

	expectation := &FeedManagerMockGetNewsFeedExpectation{
		mock:   mmGetNewsFeed.mock,
		params: &FeedManagerMockGetNewsFeedParams{ctx, userID},
	}
	mmGetNewsFeed.expectations = append(mmGetNewsFeed.expectations, expectation)
	return expectation
}

// Then sets up FeedManager.GetNewsFeed return parameters for the expectation previously defined by the When method
func (e *FeedManagerMockGetNewsFeedExpectation) Then(ta1 []entity.Tweet, err error) *FeedManagerMock {
	e.results = &FeedManagerMockGetNewsFeedResults{ta1, err}
	return e.mock
}

// GetNewsFeed implements usecase.FeedManager
func (mmGetNewsFeed *FeedManagerMock) GetNewsFeed(ctx context.Context, userID int) (ta1 []entity.Tweet, err error) {
	mm_atomic.AddUint64(&mmGetNewsFeed.beforeGetNewsFeedCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNewsFeed.afterGetNewsFeedCounter, 1)

	if mmGetNewsFeed.inspectFuncGetNewsFeed != nil {
		mmGetNewsFeed.inspectFuncGetNewsFeed(ctx, userID)
	}

	mm_params := &FeedManagerMockGetNewsFeedParams{ctx, userID}

	// Record call args
	mmGetNewsFeed.GetNewsFeedMock.mutex.Lock()
	mmGetNewsFeed.GetNewsFeedMock.callArgs = append(mmGetNewsFeed.GetNewsFeedMock.callArgs, mm_params)
	mmGetNewsFeed.GetNewsFeedMock.mutex.Unlock()

	for _, e := range mmGetNewsFeed.GetNewsFeedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ta1, e.results.err
		}
	}

	if mmGetNewsFeed.GetNewsFeedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNewsFeed.GetNewsFeedMock.defaultExpectation.Counter, 1)
		mm_want := mmGetNewsFeed.GetNewsFeedMock.defaultExpectation.params
		mm_got := FeedManagerMockGetNewsFeedParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetNewsFeed.t.Errorf("FeedManagerMock.GetNewsFeed got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetNewsFeed.GetNewsFeedMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNewsFeed.t.Fatal("No results are set for the FeedManagerMock.GetNewsFeed")
		}
		return (*mm_results).ta1, (*mm_results).err
	}
	if mmGetNewsFeed.funcGetNewsFeed != nil {
		return mmGetNewsFeed.funcGetNewsFeed(ctx, userID)
	}
	mmGetNewsFeed.t.Fatalf("Unexpected call to FeedManagerMock.GetNewsFeed. %v %v", ctx, userID)
	return
}

// GetNewsFeedAfterCounter returns a count of finished FeedManagerMock.GetNewsFeed invocations
func (mmGetNewsFeed *FeedManagerMock) GetNewsFeedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNewsFeed.afterGetNewsFeedCounter)
}

// GetNewsFeedBeforeCounter returns a count of FeedManagerMock.GetNewsFeed invocations
func (mmGetNewsFeed *FeedManagerMock) GetNewsFeedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNewsFeed.beforeGetNewsFeedCounter)
}

// Calls returns a list of arguments used in each call to FeedManagerMock.GetNewsFeed.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetNewsFeed *mFeedManagerMockGetNewsFeed) Calls() []*FeedManagerMockGetNewsFeedParams {
	mmGetNewsFeed.mutex.RLock()

	argCopy := make([]*FeedManagerMockGetNewsFeedParams, len(mmGetNewsFeed.callArgs))
	copy(argCopy, mmGetNewsFeed.callArgs)

	mmGetNewsFeed.mutex.RUnlock()

	return argCopy
}

// MinimockGetNewsFeedDone returns true if the count of the GetNewsFeed invocations corresponds
// the number of defined expectations
func (m *FeedManagerMock) MinimockGetNewsFeedDone() bool {
	for _, e := range m.GetNewsFeedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetNewsFeedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetNewsFeedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNewsFeed != nil && mm_atomic.LoadUint64(&m.afterGetNewsFeedCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetNewsFeedInspect logs each unmet expectation
func (m *FeedManagerMock) MinimockGetNewsFeedInspect() {
	for _, e := range m.GetNewsFeedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FeedManagerMock.GetNewsFeed with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetNewsFeedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetNewsFeedCounter) < 1 {
		if m.GetNewsFeedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FeedManagerMock.GetNewsFeed")
		} else {
			m.t.Errorf("Expected call to FeedManagerMock.GetNewsFeed with params: %#v", *m.GetNewsFeedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNewsFeed != nil && mm_atomic.LoadUint64(&m.afterGetNewsFeedCounter) < 1 {
		m.t.Error("Expected call to FeedManagerMock.GetNewsFeed")
	}
}

type mFeedManagerMockGetRecommendedUsers struct {
	mock               *FeedManagerMock
	defaultExpectation *FeedManagerMockGetRecommendedUsersExpectation
	expectations       []*FeedManagerMockGetRecommendedUsersExpectation

	callArgs []*FeedManagerMockGetRecommendedUsersParams
	mutex    sync.RWMutex
}

// FeedManagerMockGetRecommendedUsersExpectation specifies expectation struct of the FeedManager.GetRecommendedUsers
type FeedManagerMockGetRecommendedUsersExpectation struct {
	mock    *FeedManagerMock
	params  *FeedManagerMockGetRecommendedUsersParams
	results *FeedManagerMockGetRecommendedUsersResults
	Counter uint64
}

// FeedManagerMockGetRecommendedUsersParams contains parameters of the FeedManager.GetRecommendedUsers
type FeedManagerMockGetRecommendedUsersParams struct {
	ctx    context.Context
	userID int
}

// FeedManagerMockGetRecommendedUsersResults contains results of the FeedManager.GetRecommendedUsers
type FeedManagerMockGetRecommendedUsersResults struct {
	ua1 []entity.User
	err error
}

// Expect sets up expected params for FeedManager.GetRecommendedUsers
func (mmGetRecommendedUsers *mFeedManagerMockGetRecommendedUsers) Expect(ctx context.Context, userID int) *mFeedManagerMockGetRecommendedUsers {
	if mmGetRecommendedUsers.mock.funcGetRecommendedUsers != nil {
		mmGetRecommendedUsers.mock.t.Fatalf("FeedManagerMock.GetRecommendedUsers mock is already set by Set")
	}

	if mmGetRecommendedUsers.defaultExpectation == nil {
		mmGetRecommendedUsers.defaultExpectation = &FeedManagerMockGetRecommendedUsersExpectation{}
	}

	mmGetRecommendedUsers.defaultExpectation.params = &FeedManagerMockGetRecommendedUsersParams{ctx, userID}
	for _, e := range mmGetRecommendedUsers.expectations {
		if minimock.Equal(e.params, mmGetRecommendedUsers.defaultExpectation.params) {
			mmGetRecommendedUsers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRecommendedUsers.defaultExpectation.params)
		}
	}

	return mmGetRecommendedUsers
}

// Inspect accepts an inspector function that has same arguments as the FeedManager.GetRecommendedUsers
func (mmGetRecommendedUsers *mFeedManagerMockGetRecommendedUsers) Inspect(f func(ctx context.Context, userID int)) *mFeedManagerMockGetRecommendedUsers {
	if mmGetRecommendedUsers.mock.inspectFuncGetRecommendedUsers != nil {
		mmGetRecommendedUsers.mock.t.Fatalf("Inspect function is already set for FeedManagerMock.GetRecommendedUsers")
	}

	mmGetRecommendedUsers.mock.inspectFuncGetRecommendedUsers = f

	return mmGetRecommendedUsers
}

// Return sets up results that will be returned by FeedManager.GetRecommendedUsers
func (mmGetRecommendedUsers *mFeedManagerMockGetRecommendedUsers) Return(ua1 []entity.User, err error) *FeedManagerMock {
	if mmGetRecommendedUsers.mock.funcGetRecommendedUsers != nil {
		mmGetRecommendedUsers.mock.t.Fatalf("FeedManagerMock.GetRecommendedUsers mock is already set by Set")
	}

	if mmGetRecommendedUsers.defaultExpectation == nil {
		mmGetRecommendedUsers.defaultExpectation = &FeedManagerMockGetRecommendedUsersExpectation{mock: mmGetRecommendedUsers.mock}
	}
	mmGetRecommendedUsers.defaultExpectation.results = &FeedManagerMockGetRecommendedUsersResults{ua1, err}
	return mmGetRecommendedUsers.mock
}

// Set uses given function f to mock the FeedManager.GetRecommendedUsers method
func (mmGetRecommendedUsers *mFeedManagerMockGetRecommendedUsers) Set(f func(ctx context.Context, userID int) (ua1 []entity.User, err error)) *FeedManagerMock {
	if mmGetRecommendedUsers.defaultExpectation != nil {
		mmGetRecommendedUsers.mock.t.Fatalf("Default expectation is already set for the FeedManager.GetRecommendedUsers method")
	}

	if len(mmGetRecommendedUsers.expectations) > 0 {
		mmGetRecommendedUsers.mock.t.Fatalf("Some expectations are already set for the FeedManager.GetRecommendedUsers method")
	}

	mmGetRecommendedUsers.mock.funcGetRecommendedUsers = f
	return mmGetRecommendedUsers.mock
}

// When sets expectation for the FeedManager.GetRecommendedUsers which will trigger the result defined by the following
// Then helper
func (mmGetRecommendedUsers *mFeedManagerMockGetRecommendedUsers) When(ctx context.Context, userID int) *FeedManagerMockGetRecommendedUsersExpectation {
	if mmGetRecommendedUsers.mock.funcGetRecommendedUsers != nil {
		mmGetRecommendedUsers.mock.t.Fatalf("FeedManagerMock.GetRecommendedUsers mock is already set by Set")
	}

	expectation := &FeedManagerMockGetRecommendedUsersExpectation{
		mock:   mmGetRecommendedUsers.mock,
		params: &FeedManagerMockGetRecommendedUsersParams{ctx, userID},
	}
	mmGetRecommendedUsers.expectations = append(mmGetRecommendedUsers.expectations, expectation)
	return expectation
}

// Then sets up FeedManager.GetRecommendedUsers return parameters for the expectation previously defined by the When method
func (e *FeedManagerMockGetRecommendedUsersExpectation) Then(ua1 []entity.User, err error) *FeedManagerMock {
	e.results = &FeedManagerMockGetRecommendedUsersResults{ua1, err}
	return e.mock
}

// GetRecommendedUsers implements usecase.FeedManager
func (mmGetRecommendedUsers *FeedManagerMock) GetRecommendedUsers(ctx context.Context, userID int) (ua1 []entity.User, err error) {
	mm_atomic.AddUint64(&mmGetRecommendedUsers.beforeGetRecommendedUsersCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRecommendedUsers.afterGetRecommendedUsersCounter, 1)

	if mmGetRecommendedUsers.inspectFuncGetRecommendedUsers != nil {
		mmGetRecommendedUsers.inspectFuncGetRecommendedUsers(ctx, userID)
	}

	mm_params := &FeedManagerMockGetRecommendedUsersParams{ctx, userID}

	// Record call args
	mmGetRecommendedUsers.GetRecommendedUsersMock.mutex.Lock()
	mmGetRecommendedUsers.GetRecommendedUsersMock.callArgs = append(mmGetRecommendedUsers.GetRecommendedUsersMock.callArgs, mm_params)
	mmGetRecommendedUsers.GetRecommendedUsersMock.mutex.Unlock()

	for _, e := range mmGetRecommendedUsers.GetRecommendedUsersMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmGetRecommendedUsers.GetRecommendedUsersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRecommendedUsers.GetRecommendedUsersMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRecommendedUsers.GetRecommendedUsersMock.defaultExpectation.params
		mm_got := FeedManagerMockGetRecommendedUsersParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRecommendedUsers.t.Errorf("FeedManagerMock.GetRecommendedUsers got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRecommendedUsers.GetRecommendedUsersMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRecommendedUsers.t.Fatal("No results are set for the FeedManagerMock.GetRecommendedUsers")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmGetRecommendedUsers.funcGetRecommendedUsers != nil {
		return mmGetRecommendedUsers.funcGetRecommendedUsers(ctx, userID)
	}
	mmGetRecommendedUsers.t.Fatalf("Unexpected call to FeedManagerMock.GetRecommendedUsers. %v %v", ctx, userID)
	return
}

// GetRecommendedUsersAfterCounter returns a count of finished FeedManagerMock.GetRecommendedUsers invocations
func (mmGetRecommendedUsers *FeedManagerMock) GetRecommendedUsersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRecommendedUsers.afterGetRecommendedUsersCounter)
}

// GetRecommendedUsersBeforeCounter returns a count of FeedManagerMock.GetRecommendedUsers invocations
func (mmGetRecommendedUsers *FeedManagerMock) GetRecommendedUsersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRecommendedUsers.beforeGetRecommendedUsersCounter)
}

// Calls returns a list of arguments used in each call to FeedManagerMock.GetRecommendedUsers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRecommendedUsers *mFeedManagerMockGetRecommendedUsers) Calls() []*FeedManagerMockGetRecommendedUsersParams {
	mmGetRecommendedUsers.mutex.RLock()

	argCopy := make([]*FeedManagerMockGetRecommendedUsersParams, len(mmGetRecommendedUsers.callArgs))
	copy(argCopy, mmGetRecommendedUsers.callArgs)

	mmGetRecommendedUsers.mutex.RUnlock()

	return argCopy
}

// MinimockGetRecommendedUsersDone returns true if the count of the GetRecommendedUsers invocations corresponds
// the number of defined expectations
func (m *FeedManagerMock) MinimockGetRecommendedUsersDone() bool {
	for _, e := range m.GetRecommendedUsersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRecommendedUsersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRecommendedUsersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRecommendedUsers != nil && mm_atomic.LoadUint64(&m.afterGetRecommendedUsersCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetRecommendedUsersInspect logs each unmet expectation
func (m *FeedManagerMock) MinimockGetRecommendedUsersInspect() {
	for _, e := range m.GetRecommendedUsersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FeedManagerMock.GetRecommendedUsers with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRecommendedUsersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRecommendedUsersCounter) < 1 {
		if m.GetRecommendedUsersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FeedManagerMock.GetRecommendedUsers")
		} else {
			m.t.Errorf("Expected call to FeedManagerMock.GetRecommendedUsers with params: %#v", *m.GetRecommendedUsersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRecommendedUsers != nil && mm_atomic.LoadUint64(&m.afterGetRecommendedUsersCounter) < 1 {
		m.t.Error("Expected call to FeedManagerMock.GetRecommendedUsers")
	}
}

type mFeedManagerMockRemoveFollower struct {
	mock               *FeedManagerMock
	defaultExpectation *FeedManagerMockRemoveFollowerExpectation
	expectations       []*FeedManagerMockRemoveFollowerExpectation

	callArgs []*FeedManagerMockRemoveFollowerParams
	mutex    sync.RWMutex
}

// FeedManagerMockRemoveFollowerExpectation specifies expectation struct of the FeedManager.RemoveFollower
type FeedManagerMockRemoveFollowerExpectation struct {
	mock    *FeedManagerMock
	params  *FeedManagerMockRemoveFollowerParams
	results *FeedManagerMockRemoveFollowerResults
	Counter uint64
}

// FeedManagerMockRemoveFollowerParams contains parameters of the FeedManager.RemoveFollower
type FeedManagerMockRemoveFollowerParams struct {
	ctx        context.Context
	userID     int
	fromUserID int
}

// FeedManagerMockRemoveFollowerResults contains results of the FeedManager.RemoveFollower
type FeedManagerMockRemoveFollowerResults struct {
	err error
}

// Expect sets up expected params for FeedManager.RemoveFollower
func (mmRemoveFollower *mFeedManagerMockRemoveFollower) Expect(ctx context.Context, userID int, fromUserID int) *mFeedManagerMockRemoveFollower {
	if mmRemoveFollower.mock.funcRemoveFollower != nil {
		mmRemoveFollower.mock.t.Fatalf("FeedManagerMock.RemoveFollower mock is already set by Set")
	}

	if mmRemoveFollower.defaultExpectation == nil {
		mmRemoveFollower.defaultExpectation = &FeedManagerMockRemoveFollowerExpectation{}
	}

	mmRemoveFollower.defaultExpectation.params = &FeedManagerMockRemoveFollowerParams{ctx, userID, fromUserID}
	for _, e := range mmRemoveFollower.expectations {
		if minimock.Equal(e.params, mmRemoveFollower.defaultExpectation.params) {
			mmRemoveFollower.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveFollower.defaultExpectation.params)
		}
	}

	return mmRemoveFollower
}

// Inspect accepts an inspector function that has same arguments as the FeedManager.RemoveFollower
func (mmRemoveFollower *mFeedManagerMockRemoveFollower) Inspect(f func(ctx context.Context, userID int, fromUserID int)) *mFeedManagerMockRemoveFollower {
	if mmRemoveFollower.mock.inspectFuncRemoveFollower != nil {
		mmRemoveFollower.mock.t.Fatalf("Inspect function is already set for FeedManagerMock.RemoveFollower")
	}

	mmRemoveFollower.mock.inspectFuncRemoveFollower = f

	return mmRemoveFollower
}

// Return sets up results that will be returned by FeedManager.RemoveFollower
func (mmRemoveFollower *mFeedManagerMockRemoveFollower) Return(err error) *FeedManagerMock {
	if mmRemoveFollower.mock.funcRemoveFollower != nil {
		mmRemoveFollower.mock.t.Fatalf("FeedManagerMock.RemoveFollower mock is already set by Set")
	}

	if mmRemoveFollower.defaultExpectation == nil {
		mmRemoveFollower.defaultExpectation = &FeedManagerMockRemoveFollowerExpectation{mock: mmRemoveFollower.mock}
	}
	mmRemoveFollower.defaultExpectation.results = &FeedManagerMockRemoveFollowerResults{err}
	return mmRemoveFollower.mock
}

// Set uses given function f to mock the FeedManager.RemoveFollower method
func (mmRemoveFollower *mFeedManagerMockRemoveFollower) Set(f func(ctx context.Context, userID int, fromUserID int) (err error)) *FeedManagerMock {
	if mmRemoveFollower.defaultExpectation != nil {
		mmRemoveFollower.mock.t.Fatalf("Default expectation is already set for the FeedManager.RemoveFollower method")
	}

	if len(mmRemoveFollower.expectations) > 0 {
		mmRemoveFollower.mock.t.Fatalf("Some expectations are already set for the FeedManager.RemoveFollower method")
	}

	mmRemoveFollower.mock.funcRemoveFollower = f
	return mmRemoveFollower.mock
}

// When sets expectation for the FeedManager.RemoveFollower which will trigger the result defined by the following
// Then helper
func (mmRemoveFollower *mFeedManagerMockRemoveFollower) When(ctx context.Context, userID int, fromUserID int) *FeedManagerMockRemoveFollowerExpectation {
	if mmRemoveFollower.mock.funcRemoveFollower != nil {
		mmRemoveFollower.mock.t.Fatalf("FeedManagerMock.RemoveFollower mock is already set by Set")
	}

	expectation := &FeedManagerMockRemoveFollowerExpectation{
		mock:   mmRemoveFollower.mock,
		params: &FeedManagerMockRemoveFollowerParams{ctx, userID, fromUserID},
	}
	mmRemoveFollower.expectations = append(mmRemoveFollower.expectations, expectation)
	return expectation
}

// Then sets up FeedManager.RemoveFollower return parameters for the expectation previously defined by the When method
func (e *FeedManagerMockRemoveFollowerExpectation) Then(err error) *FeedManagerMock {
	e.results = &FeedManagerMockRemoveFollowerResults{err}
	return e.mock
}

// RemoveFollower implements usecase.FeedManager
func (mmRemoveFollower *FeedManagerMock) RemoveFollower(ctx context.Context, userID int, fromUserID int) (err error) {
	mm_atomic.AddUint64(&mmRemoveFollower.beforeRemoveFollowerCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveFollower.afterRemoveFollowerCounter, 1)

	if mmRemoveFollower.inspectFuncRemoveFollower != nil {
		mmRemoveFollower.inspectFuncRemoveFollower(ctx, userID, fromUserID)
	}

	mm_params := &FeedManagerMockRemoveFollowerParams{ctx, userID, fromUserID}

	// Record call args
	mmRemoveFollower.RemoveFollowerMock.mutex.Lock()
	mmRemoveFollower.RemoveFollowerMock.callArgs = append(mmRemoveFollower.RemoveFollowerMock.callArgs, mm_params)
	mmRemoveFollower.RemoveFollowerMock.mutex.Unlock()

	for _, e := range mmRemoveFollower.RemoveFollowerMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveFollower.RemoveFollowerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveFollower.RemoveFollowerMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveFollower.RemoveFollowerMock.defaultExpectation.params
		mm_got := FeedManagerMockRemoveFollowerParams{ctx, userID, fromUserID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveFollower.t.Errorf("FeedManagerMock.RemoveFollower got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveFollower.RemoveFollowerMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveFollower.t.Fatal("No results are set for the FeedManagerMock.RemoveFollower")
		}
		return (*mm_results).err
	}
	if mmRemoveFollower.funcRemoveFollower != nil {
		return mmRemoveFollower.funcRemoveFollower(ctx, userID, fromUserID)
	}
	mmRemoveFollower.t.Fatalf("Unexpected call to FeedManagerMock.RemoveFollower. %v %v %v", ctx, userID, fromUserID)
	return
}

// RemoveFollowerAfterCounter returns a count of finished FeedManagerMock.RemoveFollower invocations
func (mmRemoveFollower *FeedManagerMock) RemoveFollowerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveFollower.afterRemoveFollowerCounter)
}

// RemoveFollowerBeforeCounter returns a count of FeedManagerMock.RemoveFollower invocations
func (mmRemoveFollower *FeedManagerMock) RemoveFollowerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveFollower.beforeRemoveFollowerCounter)
}

// Calls returns a list of arguments used in each call to FeedManagerMock.RemoveFollower.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveFollower *mFeedManagerMockRemoveFollower) Calls() []*FeedManagerMockRemoveFollowerParams {
	mmRemoveFollower.mutex.RLock()

	argCopy := make([]*FeedManagerMockRemoveFollowerParams, len(mmRemoveFollower.callArgs))
	copy(argCopy, mmRemoveFollower.callArgs)

	mmRemoveFollower.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveFollowerDone returns true if the count of the RemoveFollower invocations corresponds
// the number of defined expectations
func (m *FeedManagerMock) MinimockRemoveFollowerDone() bool {
	for _, e := range m.RemoveFollowerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveFollowerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveFollowerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveFollower != nil && mm_atomic.LoadUint64(&m.afterRemoveFollowerCounter) < 1 {
		return false
	}
	return true
}

// MinimockRemoveFollowerInspect logs each unmet expectation
func (m *FeedManagerMock) MinimockRemoveFollowerInspect() {
	for _, e := range m.RemoveFollowerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FeedManagerMock.RemoveFollower with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveFollowerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveFollowerCounter) < 1 {
		if m.RemoveFollowerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FeedManagerMock.RemoveFollower")
		} else {
			m.t.Errorf("Expected call to FeedManagerMock.RemoveFollower with params: %#v", *m.RemoveFollowerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveFollower != nil && mm_atomic.LoadUint64(&m.afterRemoveFollowerCounter) < 1 {
		m.t.Error("Expected call to FeedManagerMock.RemoveFollower")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *FeedManagerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddFollowerInspect()

		m.MinimockAddTweetInspect()

		m.MinimockEditCommentInspect()

		m.MinimockEditTweetInspect()

		m.MinimockGetNewsFeedInspect()

		m.MinimockGetRecommendedUsersInspect()

		m.MinimockRemoveFollowerInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *FeedManagerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *FeedManagerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddFollowerDone() &&
		m.MinimockAddTweetDone() &&
		m.MinimockEditCommentDone() &&
		m.MinimockEditTweetDone() &&
		m.MinimockGetNewsFeedDone() &&
		m.MinimockGetRecommendedUsersDone() &&
		m.MinimockRemoveFollowerDone()
}
