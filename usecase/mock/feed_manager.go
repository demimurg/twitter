package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"
	"github.com/demimurg/twitter/entity"

	"github.com/gojuno/minimock/v3"
)

// FeedManagerMock implements twitter.FeedManager
type FeedManagerMock struct {
	t minimock.Tester

	funcAddNewTweet          func(userID string, text string) (err error)
	inspectFuncAddNewTweet   func(userID string, text string)
	afterAddNewTweetCounter  uint64
	beforeAddNewTweetCounter uint64
	AddNewTweetMock          mFeedManagerMockAddNewTweet

	funcEditComment          func(commentID string, text string) (err error)
	inspectFuncEditComment   func(commentID string, text string)
	afterEditCommentCounter  uint64
	beforeEditCommentCounter uint64
	EditCommentMock          mFeedManagerMockEditComment

	funcEditTweet          func(messageID string, text string) (err error)
	inspectFuncEditTweet   func(messageID string, text string)
	afterEditTweetCounter  uint64
	beforeEditTweetCounter uint64
	EditTweetMock          mFeedManagerMockEditTweet

	funcGiveNewsFeed          func(userID string) (np1 *entity.NewsFeed, err error)
	inspectFuncGiveNewsFeed   func(userID string)
	afterGiveNewsFeedCounter  uint64
	beforeGiveNewsFeedCounter uint64
	GiveNewsFeedMock          mFeedManagerMockGiveNewsFeed
}

// NewFeedManagerMock returns a mock for twitter.FeedManager
func NewFeedManagerMock(t minimock.Tester) *FeedManagerMock {
	m := &FeedManagerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddNewTweetMock = mFeedManagerMockAddNewTweet{mock: m}
	m.AddNewTweetMock.callArgs = []*FeedManagerMockAddNewTweetParams{}

	m.EditCommentMock = mFeedManagerMockEditComment{mock: m}
	m.EditCommentMock.callArgs = []*FeedManagerMockEditCommentParams{}

	m.EditTweetMock = mFeedManagerMockEditTweet{mock: m}
	m.EditTweetMock.callArgs = []*FeedManagerMockEditTweetParams{}

	m.GiveNewsFeedMock = mFeedManagerMockGiveNewsFeed{mock: m}
	m.GiveNewsFeedMock.callArgs = []*FeedManagerMockGiveNewsFeedParams{}

	return m
}

type mFeedManagerMockAddNewTweet struct {
	mock               *FeedManagerMock
	defaultExpectation *FeedManagerMockAddNewTweetExpectation
	expectations       []*FeedManagerMockAddNewTweetExpectation

	callArgs []*FeedManagerMockAddNewTweetParams
	mutex    sync.RWMutex
}

// FeedManagerMockAddNewTweetExpectation specifies expectation struct of the FeedManager.AddNewTweet
type FeedManagerMockAddNewTweetExpectation struct {
	mock    *FeedManagerMock
	params  *FeedManagerMockAddNewTweetParams
	results *FeedManagerMockAddNewTweetResults
	Counter uint64
}

// FeedManagerMockAddNewTweetParams contains parameters of the FeedManager.AddNewTweet
type FeedManagerMockAddNewTweetParams struct {
	userID string
	text   string
}

// FeedManagerMockAddNewTweetResults contains results of the FeedManager.AddNewTweet
type FeedManagerMockAddNewTweetResults struct {
	err error
}

// Expect sets up expected params for FeedManager.AddNewTweet
func (mmAddNewTweet *mFeedManagerMockAddNewTweet) Expect(userID string, text string) *mFeedManagerMockAddNewTweet {
	if mmAddNewTweet.mock.funcAddNewTweet != nil {
		mmAddNewTweet.mock.t.Fatalf("FeedManagerMock.AddNewTweet mock is already set by Set")
	}

	if mmAddNewTweet.defaultExpectation == nil {
		mmAddNewTweet.defaultExpectation = &FeedManagerMockAddNewTweetExpectation{}
	}

	mmAddNewTweet.defaultExpectation.params = &FeedManagerMockAddNewTweetParams{userID, text}
	for _, e := range mmAddNewTweet.expectations {
		if minimock.Equal(e.params, mmAddNewTweet.defaultExpectation.params) {
			mmAddNewTweet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddNewTweet.defaultExpectation.params)
		}
	}

	return mmAddNewTweet
}

// Inspect accepts an inspector function that has same arguments as the FeedManager.AddNewTweet
func (mmAddNewTweet *mFeedManagerMockAddNewTweet) Inspect(f func(userID string, text string)) *mFeedManagerMockAddNewTweet {
	if mmAddNewTweet.mock.inspectFuncAddNewTweet != nil {
		mmAddNewTweet.mock.t.Fatalf("Inspect function is already set for FeedManagerMock.AddNewTweet")
	}

	mmAddNewTweet.mock.inspectFuncAddNewTweet = f

	return mmAddNewTweet
}

// Return sets up results that will be returned by FeedManager.AddNewTweet
func (mmAddNewTweet *mFeedManagerMockAddNewTweet) Return(err error) *FeedManagerMock {
	if mmAddNewTweet.mock.funcAddNewTweet != nil {
		mmAddNewTweet.mock.t.Fatalf("FeedManagerMock.AddNewTweet mock is already set by Set")
	}

	if mmAddNewTweet.defaultExpectation == nil {
		mmAddNewTweet.defaultExpectation = &FeedManagerMockAddNewTweetExpectation{mock: mmAddNewTweet.mock}
	}
	mmAddNewTweet.defaultExpectation.results = &FeedManagerMockAddNewTweetResults{err}
	return mmAddNewTweet.mock
}

//Set uses given function f to mock the FeedManager.AddNewTweet method
func (mmAddNewTweet *mFeedManagerMockAddNewTweet) Set(f func(userID string, text string) (err error)) *FeedManagerMock {
	if mmAddNewTweet.defaultExpectation != nil {
		mmAddNewTweet.mock.t.Fatalf("Default expectation is already set for the FeedManager.AddNewTweet method")
	}

	if len(mmAddNewTweet.expectations) > 0 {
		mmAddNewTweet.mock.t.Fatalf("Some expectations are already set for the FeedManager.AddNewTweet method")
	}

	mmAddNewTweet.mock.funcAddNewTweet = f
	return mmAddNewTweet.mock
}

// When sets expectation for the FeedManager.AddNewTweet which will trigger the result defined by the following
// Then helper
func (mmAddNewTweet *mFeedManagerMockAddNewTweet) When(userID string, text string) *FeedManagerMockAddNewTweetExpectation {
	if mmAddNewTweet.mock.funcAddNewTweet != nil {
		mmAddNewTweet.mock.t.Fatalf("FeedManagerMock.AddNewTweet mock is already set by Set")
	}

	expectation := &FeedManagerMockAddNewTweetExpectation{
		mock:   mmAddNewTweet.mock,
		params: &FeedManagerMockAddNewTweetParams{userID, text},
	}
	mmAddNewTweet.expectations = append(mmAddNewTweet.expectations, expectation)
	return expectation
}

// Then sets up FeedManager.AddNewTweet return parameters for the expectation previously defined by the When method
func (e *FeedManagerMockAddNewTweetExpectation) Then(err error) *FeedManagerMock {
	e.results = &FeedManagerMockAddNewTweetResults{err}
	return e.mock
}

// AddNewTweet implements twitter.FeedManager
func (mmAddNewTweet *FeedManagerMock) AddNewTweet(userID string, text string) (err error) {
	mm_atomic.AddUint64(&mmAddNewTweet.beforeAddNewTweetCounter, 1)
	defer mm_atomic.AddUint64(&mmAddNewTweet.afterAddNewTweetCounter, 1)

	if mmAddNewTweet.inspectFuncAddNewTweet != nil {
		mmAddNewTweet.inspectFuncAddNewTweet(userID, text)
	}

	mm_params := &FeedManagerMockAddNewTweetParams{userID, text}

	// Record call args
	mmAddNewTweet.AddNewTweetMock.mutex.Lock()
	mmAddNewTweet.AddNewTweetMock.callArgs = append(mmAddNewTweet.AddNewTweetMock.callArgs, mm_params)
	mmAddNewTweet.AddNewTweetMock.mutex.Unlock()

	for _, e := range mmAddNewTweet.AddNewTweetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddNewTweet.AddNewTweetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddNewTweet.AddNewTweetMock.defaultExpectation.Counter, 1)
		mm_want := mmAddNewTweet.AddNewTweetMock.defaultExpectation.params
		mm_got := FeedManagerMockAddNewTweetParams{userID, text}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddNewTweet.t.Errorf("FeedManagerMock.AddNewTweet got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddNewTweet.AddNewTweetMock.defaultExpectation.results
		if mm_results == nil {
			mmAddNewTweet.t.Fatal("No results are set for the FeedManagerMock.AddNewTweet")
		}
		return (*mm_results).err
	}
	if mmAddNewTweet.funcAddNewTweet != nil {
		return mmAddNewTweet.funcAddNewTweet(userID, text)
	}
	mmAddNewTweet.t.Fatalf("Unexpected call to FeedManagerMock.AddNewTweet. %v %v", userID, text)
	return
}

// AddNewTweetAfterCounter returns a count of finished FeedManagerMock.AddNewTweet invocations
func (mmAddNewTweet *FeedManagerMock) AddNewTweetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddNewTweet.afterAddNewTweetCounter)
}

// AddNewTweetBeforeCounter returns a count of FeedManagerMock.AddNewTweet invocations
func (mmAddNewTweet *FeedManagerMock) AddNewTweetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddNewTweet.beforeAddNewTweetCounter)
}

// Calls returns a list of arguments used in each call to FeedManagerMock.AddNewTweet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddNewTweet *mFeedManagerMockAddNewTweet) Calls() []*FeedManagerMockAddNewTweetParams {
	mmAddNewTweet.mutex.RLock()

	argCopy := make([]*FeedManagerMockAddNewTweetParams, len(mmAddNewTweet.callArgs))
	copy(argCopy, mmAddNewTweet.callArgs)

	mmAddNewTweet.mutex.RUnlock()

	return argCopy
}

// MinimockAddNewTweetDone returns true if the count of the AddNewTweet invocations corresponds
// the number of defined expectations
func (m *FeedManagerMock) MinimockAddNewTweetDone() bool {
	for _, e := range m.AddNewTweetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddNewTweetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddNewTweetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddNewTweet != nil && mm_atomic.LoadUint64(&m.afterAddNewTweetCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddNewTweetInspect logs each unmet expectation
func (m *FeedManagerMock) MinimockAddNewTweetInspect() {
	for _, e := range m.AddNewTweetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FeedManagerMock.AddNewTweet with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddNewTweetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddNewTweetCounter) < 1 {
		if m.AddNewTweetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FeedManagerMock.AddNewTweet")
		} else {
			m.t.Errorf("Expected call to FeedManagerMock.AddNewTweet with params: %#v", *m.AddNewTweetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddNewTweet != nil && mm_atomic.LoadUint64(&m.afterAddNewTweetCounter) < 1 {
		m.t.Error("Expected call to FeedManagerMock.AddNewTweet")
	}
}

type mFeedManagerMockEditComment struct {
	mock               *FeedManagerMock
	defaultExpectation *FeedManagerMockEditCommentExpectation
	expectations       []*FeedManagerMockEditCommentExpectation

	callArgs []*FeedManagerMockEditCommentParams
	mutex    sync.RWMutex
}

// FeedManagerMockEditCommentExpectation specifies expectation struct of the FeedManager.EditComment
type FeedManagerMockEditCommentExpectation struct {
	mock    *FeedManagerMock
	params  *FeedManagerMockEditCommentParams
	results *FeedManagerMockEditCommentResults
	Counter uint64
}

// FeedManagerMockEditCommentParams contains parameters of the FeedManager.EditComment
type FeedManagerMockEditCommentParams struct {
	commentID string
	text      string
}

// FeedManagerMockEditCommentResults contains results of the FeedManager.EditComment
type FeedManagerMockEditCommentResults struct {
	err error
}

// Expect sets up expected params for FeedManager.EditComment
func (mmEditComment *mFeedManagerMockEditComment) Expect(commentID string, text string) *mFeedManagerMockEditComment {
	if mmEditComment.mock.funcEditComment != nil {
		mmEditComment.mock.t.Fatalf("FeedManagerMock.EditComment mock is already set by Set")
	}

	if mmEditComment.defaultExpectation == nil {
		mmEditComment.defaultExpectation = &FeedManagerMockEditCommentExpectation{}
	}

	mmEditComment.defaultExpectation.params = &FeedManagerMockEditCommentParams{commentID, text}
	for _, e := range mmEditComment.expectations {
		if minimock.Equal(e.params, mmEditComment.defaultExpectation.params) {
			mmEditComment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEditComment.defaultExpectation.params)
		}
	}

	return mmEditComment
}

// Inspect accepts an inspector function that has same arguments as the FeedManager.EditComment
func (mmEditComment *mFeedManagerMockEditComment) Inspect(f func(commentID string, text string)) *mFeedManagerMockEditComment {
	if mmEditComment.mock.inspectFuncEditComment != nil {
		mmEditComment.mock.t.Fatalf("Inspect function is already set for FeedManagerMock.EditComment")
	}

	mmEditComment.mock.inspectFuncEditComment = f

	return mmEditComment
}

// Return sets up results that will be returned by FeedManager.EditComment
func (mmEditComment *mFeedManagerMockEditComment) Return(err error) *FeedManagerMock {
	if mmEditComment.mock.funcEditComment != nil {
		mmEditComment.mock.t.Fatalf("FeedManagerMock.EditComment mock is already set by Set")
	}

	if mmEditComment.defaultExpectation == nil {
		mmEditComment.defaultExpectation = &FeedManagerMockEditCommentExpectation{mock: mmEditComment.mock}
	}
	mmEditComment.defaultExpectation.results = &FeedManagerMockEditCommentResults{err}
	return mmEditComment.mock
}

//Set uses given function f to mock the FeedManager.EditComment method
func (mmEditComment *mFeedManagerMockEditComment) Set(f func(commentID string, text string) (err error)) *FeedManagerMock {
	if mmEditComment.defaultExpectation != nil {
		mmEditComment.mock.t.Fatalf("Default expectation is already set for the FeedManager.EditComment method")
	}

	if len(mmEditComment.expectations) > 0 {
		mmEditComment.mock.t.Fatalf("Some expectations are already set for the FeedManager.EditComment method")
	}

	mmEditComment.mock.funcEditComment = f
	return mmEditComment.mock
}

// When sets expectation for the FeedManager.EditComment which will trigger the result defined by the following
// Then helper
func (mmEditComment *mFeedManagerMockEditComment) When(commentID string, text string) *FeedManagerMockEditCommentExpectation {
	if mmEditComment.mock.funcEditComment != nil {
		mmEditComment.mock.t.Fatalf("FeedManagerMock.EditComment mock is already set by Set")
	}

	expectation := &FeedManagerMockEditCommentExpectation{
		mock:   mmEditComment.mock,
		params: &FeedManagerMockEditCommentParams{commentID, text},
	}
	mmEditComment.expectations = append(mmEditComment.expectations, expectation)
	return expectation
}

// Then sets up FeedManager.EditComment return parameters for the expectation previously defined by the When method
func (e *FeedManagerMockEditCommentExpectation) Then(err error) *FeedManagerMock {
	e.results = &FeedManagerMockEditCommentResults{err}
	return e.mock
}

// EditComment implements twitter.FeedManager
func (mmEditComment *FeedManagerMock) EditComment(commentID string, text string) (err error) {
	mm_atomic.AddUint64(&mmEditComment.beforeEditCommentCounter, 1)
	defer mm_atomic.AddUint64(&mmEditComment.afterEditCommentCounter, 1)

	if mmEditComment.inspectFuncEditComment != nil {
		mmEditComment.inspectFuncEditComment(commentID, text)
	}

	mm_params := &FeedManagerMockEditCommentParams{commentID, text}

	// Record call args
	mmEditComment.EditCommentMock.mutex.Lock()
	mmEditComment.EditCommentMock.callArgs = append(mmEditComment.EditCommentMock.callArgs, mm_params)
	mmEditComment.EditCommentMock.mutex.Unlock()

	for _, e := range mmEditComment.EditCommentMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmEditComment.EditCommentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEditComment.EditCommentMock.defaultExpectation.Counter, 1)
		mm_want := mmEditComment.EditCommentMock.defaultExpectation.params
		mm_got := FeedManagerMockEditCommentParams{commentID, text}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEditComment.t.Errorf("FeedManagerMock.EditComment got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEditComment.EditCommentMock.defaultExpectation.results
		if mm_results == nil {
			mmEditComment.t.Fatal("No results are set for the FeedManagerMock.EditComment")
		}
		return (*mm_results).err
	}
	if mmEditComment.funcEditComment != nil {
		return mmEditComment.funcEditComment(commentID, text)
	}
	mmEditComment.t.Fatalf("Unexpected call to FeedManagerMock.EditComment. %v %v", commentID, text)
	return
}

// EditCommentAfterCounter returns a count of finished FeedManagerMock.EditComment invocations
func (mmEditComment *FeedManagerMock) EditCommentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEditComment.afterEditCommentCounter)
}

// EditCommentBeforeCounter returns a count of FeedManagerMock.EditComment invocations
func (mmEditComment *FeedManagerMock) EditCommentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEditComment.beforeEditCommentCounter)
}

// Calls returns a list of arguments used in each call to FeedManagerMock.EditComment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEditComment *mFeedManagerMockEditComment) Calls() []*FeedManagerMockEditCommentParams {
	mmEditComment.mutex.RLock()

	argCopy := make([]*FeedManagerMockEditCommentParams, len(mmEditComment.callArgs))
	copy(argCopy, mmEditComment.callArgs)

	mmEditComment.mutex.RUnlock()

	return argCopy
}

// MinimockEditCommentDone returns true if the count of the EditComment invocations corresponds
// the number of defined expectations
func (m *FeedManagerMock) MinimockEditCommentDone() bool {
	for _, e := range m.EditCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EditCommentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEditCommentCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEditComment != nil && mm_atomic.LoadUint64(&m.afterEditCommentCounter) < 1 {
		return false
	}
	return true
}

// MinimockEditCommentInspect logs each unmet expectation
func (m *FeedManagerMock) MinimockEditCommentInspect() {
	for _, e := range m.EditCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FeedManagerMock.EditComment with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EditCommentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEditCommentCounter) < 1 {
		if m.EditCommentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FeedManagerMock.EditComment")
		} else {
			m.t.Errorf("Expected call to FeedManagerMock.EditComment with params: %#v", *m.EditCommentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEditComment != nil && mm_atomic.LoadUint64(&m.afterEditCommentCounter) < 1 {
		m.t.Error("Expected call to FeedManagerMock.EditComment")
	}
}

type mFeedManagerMockEditTweet struct {
	mock               *FeedManagerMock
	defaultExpectation *FeedManagerMockEditTweetExpectation
	expectations       []*FeedManagerMockEditTweetExpectation

	callArgs []*FeedManagerMockEditTweetParams
	mutex    sync.RWMutex
}

// FeedManagerMockEditTweetExpectation specifies expectation struct of the FeedManager.EditTweet
type FeedManagerMockEditTweetExpectation struct {
	mock    *FeedManagerMock
	params  *FeedManagerMockEditTweetParams
	results *FeedManagerMockEditTweetResults
	Counter uint64
}

// FeedManagerMockEditTweetParams contains parameters of the FeedManager.EditTweet
type FeedManagerMockEditTweetParams struct {
	messageID string
	text      string
}

// FeedManagerMockEditTweetResults contains results of the FeedManager.EditTweet
type FeedManagerMockEditTweetResults struct {
	err error
}

// Expect sets up expected params for FeedManager.EditTweet
func (mmEditTweet *mFeedManagerMockEditTweet) Expect(messageID string, text string) *mFeedManagerMockEditTweet {
	if mmEditTweet.mock.funcEditTweet != nil {
		mmEditTweet.mock.t.Fatalf("FeedManagerMock.EditTweet mock is already set by Set")
	}

	if mmEditTweet.defaultExpectation == nil {
		mmEditTweet.defaultExpectation = &FeedManagerMockEditTweetExpectation{}
	}

	mmEditTweet.defaultExpectation.params = &FeedManagerMockEditTweetParams{messageID, text}
	for _, e := range mmEditTweet.expectations {
		if minimock.Equal(e.params, mmEditTweet.defaultExpectation.params) {
			mmEditTweet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEditTweet.defaultExpectation.params)
		}
	}

	return mmEditTweet
}

// Inspect accepts an inspector function that has same arguments as the FeedManager.EditTweet
func (mmEditTweet *mFeedManagerMockEditTweet) Inspect(f func(messageID string, text string)) *mFeedManagerMockEditTweet {
	if mmEditTweet.mock.inspectFuncEditTweet != nil {
		mmEditTweet.mock.t.Fatalf("Inspect function is already set for FeedManagerMock.EditTweet")
	}

	mmEditTweet.mock.inspectFuncEditTweet = f

	return mmEditTweet
}

// Return sets up results that will be returned by FeedManager.EditTweet
func (mmEditTweet *mFeedManagerMockEditTweet) Return(err error) *FeedManagerMock {
	if mmEditTweet.mock.funcEditTweet != nil {
		mmEditTweet.mock.t.Fatalf("FeedManagerMock.EditTweet mock is already set by Set")
	}

	if mmEditTweet.defaultExpectation == nil {
		mmEditTweet.defaultExpectation = &FeedManagerMockEditTweetExpectation{mock: mmEditTweet.mock}
	}
	mmEditTweet.defaultExpectation.results = &FeedManagerMockEditTweetResults{err}
	return mmEditTweet.mock
}

//Set uses given function f to mock the FeedManager.EditTweet method
func (mmEditTweet *mFeedManagerMockEditTweet) Set(f func(messageID string, text string) (err error)) *FeedManagerMock {
	if mmEditTweet.defaultExpectation != nil {
		mmEditTweet.mock.t.Fatalf("Default expectation is already set for the FeedManager.EditTweet method")
	}

	if len(mmEditTweet.expectations) > 0 {
		mmEditTweet.mock.t.Fatalf("Some expectations are already set for the FeedManager.EditTweet method")
	}

	mmEditTweet.mock.funcEditTweet = f
	return mmEditTweet.mock
}

// When sets expectation for the FeedManager.EditTweet which will trigger the result defined by the following
// Then helper
func (mmEditTweet *mFeedManagerMockEditTweet) When(messageID string, text string) *FeedManagerMockEditTweetExpectation {
	if mmEditTweet.mock.funcEditTweet != nil {
		mmEditTweet.mock.t.Fatalf("FeedManagerMock.EditTweet mock is already set by Set")
	}

	expectation := &FeedManagerMockEditTweetExpectation{
		mock:   mmEditTweet.mock,
		params: &FeedManagerMockEditTweetParams{messageID, text},
	}
	mmEditTweet.expectations = append(mmEditTweet.expectations, expectation)
	return expectation
}

// Then sets up FeedManager.EditTweet return parameters for the expectation previously defined by the When method
func (e *FeedManagerMockEditTweetExpectation) Then(err error) *FeedManagerMock {
	e.results = &FeedManagerMockEditTweetResults{err}
	return e.mock
}

// EditTweet implements twitter.FeedManager
func (mmEditTweet *FeedManagerMock) EditTweet(messageID string, text string) (err error) {
	mm_atomic.AddUint64(&mmEditTweet.beforeEditTweetCounter, 1)
	defer mm_atomic.AddUint64(&mmEditTweet.afterEditTweetCounter, 1)

	if mmEditTweet.inspectFuncEditTweet != nil {
		mmEditTweet.inspectFuncEditTweet(messageID, text)
	}

	mm_params := &FeedManagerMockEditTweetParams{messageID, text}

	// Record call args
	mmEditTweet.EditTweetMock.mutex.Lock()
	mmEditTweet.EditTweetMock.callArgs = append(mmEditTweet.EditTweetMock.callArgs, mm_params)
	mmEditTweet.EditTweetMock.mutex.Unlock()

	for _, e := range mmEditTweet.EditTweetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmEditTweet.EditTweetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEditTweet.EditTweetMock.defaultExpectation.Counter, 1)
		mm_want := mmEditTweet.EditTweetMock.defaultExpectation.params
		mm_got := FeedManagerMockEditTweetParams{messageID, text}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEditTweet.t.Errorf("FeedManagerMock.EditTweet got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEditTweet.EditTweetMock.defaultExpectation.results
		if mm_results == nil {
			mmEditTweet.t.Fatal("No results are set for the FeedManagerMock.EditTweet")
		}
		return (*mm_results).err
	}
	if mmEditTweet.funcEditTweet != nil {
		return mmEditTweet.funcEditTweet(messageID, text)
	}
	mmEditTweet.t.Fatalf("Unexpected call to FeedManagerMock.EditTweet. %v %v", messageID, text)
	return
}

// EditTweetAfterCounter returns a count of finished FeedManagerMock.EditTweet invocations
func (mmEditTweet *FeedManagerMock) EditTweetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEditTweet.afterEditTweetCounter)
}

// EditTweetBeforeCounter returns a count of FeedManagerMock.EditTweet invocations
func (mmEditTweet *FeedManagerMock) EditTweetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEditTweet.beforeEditTweetCounter)
}

// Calls returns a list of arguments used in each call to FeedManagerMock.EditTweet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEditTweet *mFeedManagerMockEditTweet) Calls() []*FeedManagerMockEditTweetParams {
	mmEditTweet.mutex.RLock()

	argCopy := make([]*FeedManagerMockEditTweetParams, len(mmEditTweet.callArgs))
	copy(argCopy, mmEditTweet.callArgs)

	mmEditTweet.mutex.RUnlock()

	return argCopy
}

// MinimockEditTweetDone returns true if the count of the EditTweet invocations corresponds
// the number of defined expectations
func (m *FeedManagerMock) MinimockEditTweetDone() bool {
	for _, e := range m.EditTweetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EditTweetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEditTweetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEditTweet != nil && mm_atomic.LoadUint64(&m.afterEditTweetCounter) < 1 {
		return false
	}
	return true
}

// MinimockEditTweetInspect logs each unmet expectation
func (m *FeedManagerMock) MinimockEditTweetInspect() {
	for _, e := range m.EditTweetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FeedManagerMock.EditTweet with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EditTweetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEditTweetCounter) < 1 {
		if m.EditTweetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FeedManagerMock.EditTweet")
		} else {
			m.t.Errorf("Expected call to FeedManagerMock.EditTweet with params: %#v", *m.EditTweetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEditTweet != nil && mm_atomic.LoadUint64(&m.afterEditTweetCounter) < 1 {
		m.t.Error("Expected call to FeedManagerMock.EditTweet")
	}
}

type mFeedManagerMockGiveNewsFeed struct {
	mock               *FeedManagerMock
	defaultExpectation *FeedManagerMockGiveNewsFeedExpectation
	expectations       []*FeedManagerMockGiveNewsFeedExpectation

	callArgs []*FeedManagerMockGiveNewsFeedParams
	mutex    sync.RWMutex
}

// FeedManagerMockGiveNewsFeedExpectation specifies expectation struct of the FeedManager.GiveNewsFeed
type FeedManagerMockGiveNewsFeedExpectation struct {
	mock    *FeedManagerMock
	params  *FeedManagerMockGiveNewsFeedParams
	results *FeedManagerMockGiveNewsFeedResults
	Counter uint64
}

// FeedManagerMockGiveNewsFeedParams contains parameters of the FeedManager.GiveNewsFeed
type FeedManagerMockGiveNewsFeedParams struct {
	userID string
}

// FeedManagerMockGiveNewsFeedResults contains results of the FeedManager.GiveNewsFeed
type FeedManagerMockGiveNewsFeedResults struct {
	np1 *entity.NewsFeed
	err error
}

// Expect sets up expected params for FeedManager.GiveNewsFeed
func (mmGiveNewsFeed *mFeedManagerMockGiveNewsFeed) Expect(userID string) *mFeedManagerMockGiveNewsFeed {
	if mmGiveNewsFeed.mock.funcGiveNewsFeed != nil {
		mmGiveNewsFeed.mock.t.Fatalf("FeedManagerMock.GiveNewsFeed mock is already set by Set")
	}

	if mmGiveNewsFeed.defaultExpectation == nil {
		mmGiveNewsFeed.defaultExpectation = &FeedManagerMockGiveNewsFeedExpectation{}
	}

	mmGiveNewsFeed.defaultExpectation.params = &FeedManagerMockGiveNewsFeedParams{userID}
	for _, e := range mmGiveNewsFeed.expectations {
		if minimock.Equal(e.params, mmGiveNewsFeed.defaultExpectation.params) {
			mmGiveNewsFeed.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGiveNewsFeed.defaultExpectation.params)
		}
	}

	return mmGiveNewsFeed
}

// Inspect accepts an inspector function that has same arguments as the FeedManager.GiveNewsFeed
func (mmGiveNewsFeed *mFeedManagerMockGiveNewsFeed) Inspect(f func(userID string)) *mFeedManagerMockGiveNewsFeed {
	if mmGiveNewsFeed.mock.inspectFuncGiveNewsFeed != nil {
		mmGiveNewsFeed.mock.t.Fatalf("Inspect function is already set for FeedManagerMock.GiveNewsFeed")
	}

	mmGiveNewsFeed.mock.inspectFuncGiveNewsFeed = f

	return mmGiveNewsFeed
}

// Return sets up results that will be returned by FeedManager.GiveNewsFeed
func (mmGiveNewsFeed *mFeedManagerMockGiveNewsFeed) Return(np1 *entity.NewsFeed, err error) *FeedManagerMock {
	if mmGiveNewsFeed.mock.funcGiveNewsFeed != nil {
		mmGiveNewsFeed.mock.t.Fatalf("FeedManagerMock.GiveNewsFeed mock is already set by Set")
	}

	if mmGiveNewsFeed.defaultExpectation == nil {
		mmGiveNewsFeed.defaultExpectation = &FeedManagerMockGiveNewsFeedExpectation{mock: mmGiveNewsFeed.mock}
	}
	mmGiveNewsFeed.defaultExpectation.results = &FeedManagerMockGiveNewsFeedResults{np1, err}
	return mmGiveNewsFeed.mock
}

//Set uses given function f to mock the FeedManager.GiveNewsFeed method
func (mmGiveNewsFeed *mFeedManagerMockGiveNewsFeed) Set(f func(userID string) (np1 *entity.NewsFeed, err error)) *FeedManagerMock {
	if mmGiveNewsFeed.defaultExpectation != nil {
		mmGiveNewsFeed.mock.t.Fatalf("Default expectation is already set for the FeedManager.GiveNewsFeed method")
	}

	if len(mmGiveNewsFeed.expectations) > 0 {
		mmGiveNewsFeed.mock.t.Fatalf("Some expectations are already set for the FeedManager.GiveNewsFeed method")
	}

	mmGiveNewsFeed.mock.funcGiveNewsFeed = f
	return mmGiveNewsFeed.mock
}

// When sets expectation for the FeedManager.GiveNewsFeed which will trigger the result defined by the following
// Then helper
func (mmGiveNewsFeed *mFeedManagerMockGiveNewsFeed) When(userID string) *FeedManagerMockGiveNewsFeedExpectation {
	if mmGiveNewsFeed.mock.funcGiveNewsFeed != nil {
		mmGiveNewsFeed.mock.t.Fatalf("FeedManagerMock.GiveNewsFeed mock is already set by Set")
	}

	expectation := &FeedManagerMockGiveNewsFeedExpectation{
		mock:   mmGiveNewsFeed.mock,
		params: &FeedManagerMockGiveNewsFeedParams{userID},
	}
	mmGiveNewsFeed.expectations = append(mmGiveNewsFeed.expectations, expectation)
	return expectation
}

// Then sets up FeedManager.GiveNewsFeed return parameters for the expectation previously defined by the When method
func (e *FeedManagerMockGiveNewsFeedExpectation) Then(np1 *entity.NewsFeed, err error) *FeedManagerMock {
	e.results = &FeedManagerMockGiveNewsFeedResults{np1, err}
	return e.mock
}

// GiveNewsFeed implements twitter.FeedManager
func (mmGiveNewsFeed *FeedManagerMock) GiveNewsFeed(userID string) (np1 *entity.NewsFeed, err error) {
	mm_atomic.AddUint64(&mmGiveNewsFeed.beforeGiveNewsFeedCounter, 1)
	defer mm_atomic.AddUint64(&mmGiveNewsFeed.afterGiveNewsFeedCounter, 1)

	if mmGiveNewsFeed.inspectFuncGiveNewsFeed != nil {
		mmGiveNewsFeed.inspectFuncGiveNewsFeed(userID)
	}

	mm_params := &FeedManagerMockGiveNewsFeedParams{userID}

	// Record call args
	mmGiveNewsFeed.GiveNewsFeedMock.mutex.Lock()
	mmGiveNewsFeed.GiveNewsFeedMock.callArgs = append(mmGiveNewsFeed.GiveNewsFeedMock.callArgs, mm_params)
	mmGiveNewsFeed.GiveNewsFeedMock.mutex.Unlock()

	for _, e := range mmGiveNewsFeed.GiveNewsFeedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.np1, e.results.err
		}
	}

	if mmGiveNewsFeed.GiveNewsFeedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGiveNewsFeed.GiveNewsFeedMock.defaultExpectation.Counter, 1)
		mm_want := mmGiveNewsFeed.GiveNewsFeedMock.defaultExpectation.params
		mm_got := FeedManagerMockGiveNewsFeedParams{userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGiveNewsFeed.t.Errorf("FeedManagerMock.GiveNewsFeed got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGiveNewsFeed.GiveNewsFeedMock.defaultExpectation.results
		if mm_results == nil {
			mmGiveNewsFeed.t.Fatal("No results are set for the FeedManagerMock.GiveNewsFeed")
		}
		return (*mm_results).np1, (*mm_results).err
	}
	if mmGiveNewsFeed.funcGiveNewsFeed != nil {
		return mmGiveNewsFeed.funcGiveNewsFeed(userID)
	}
	mmGiveNewsFeed.t.Fatalf("Unexpected call to FeedManagerMock.GiveNewsFeed. %v", userID)
	return
}

// GiveNewsFeedAfterCounter returns a count of finished FeedManagerMock.GiveNewsFeed invocations
func (mmGiveNewsFeed *FeedManagerMock) GiveNewsFeedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGiveNewsFeed.afterGiveNewsFeedCounter)
}

// GiveNewsFeedBeforeCounter returns a count of FeedManagerMock.GiveNewsFeed invocations
func (mmGiveNewsFeed *FeedManagerMock) GiveNewsFeedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGiveNewsFeed.beforeGiveNewsFeedCounter)
}

// Calls returns a list of arguments used in each call to FeedManagerMock.GiveNewsFeed.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGiveNewsFeed *mFeedManagerMockGiveNewsFeed) Calls() []*FeedManagerMockGiveNewsFeedParams {
	mmGiveNewsFeed.mutex.RLock()

	argCopy := make([]*FeedManagerMockGiveNewsFeedParams, len(mmGiveNewsFeed.callArgs))
	copy(argCopy, mmGiveNewsFeed.callArgs)

	mmGiveNewsFeed.mutex.RUnlock()

	return argCopy
}

// MinimockGiveNewsFeedDone returns true if the count of the GiveNewsFeed invocations corresponds
// the number of defined expectations
func (m *FeedManagerMock) MinimockGiveNewsFeedDone() bool {
	for _, e := range m.GiveNewsFeedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GiveNewsFeedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGiveNewsFeedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGiveNewsFeed != nil && mm_atomic.LoadUint64(&m.afterGiveNewsFeedCounter) < 1 {
		return false
	}
	return true
}

// MinimockGiveNewsFeedInspect logs each unmet expectation
func (m *FeedManagerMock) MinimockGiveNewsFeedInspect() {
	for _, e := range m.GiveNewsFeedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FeedManagerMock.GiveNewsFeed with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GiveNewsFeedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGiveNewsFeedCounter) < 1 {
		if m.GiveNewsFeedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FeedManagerMock.GiveNewsFeed")
		} else {
			m.t.Errorf("Expected call to FeedManagerMock.GiveNewsFeed with params: %#v", *m.GiveNewsFeedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGiveNewsFeed != nil && mm_atomic.LoadUint64(&m.afterGiveNewsFeedCounter) < 1 {
		m.t.Error("Expected call to FeedManagerMock.GiveNewsFeed")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *FeedManagerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddNewTweetInspect()

		m.MinimockEditCommentInspect()

		m.MinimockEditTweetInspect()

		m.MinimockGiveNewsFeedInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *FeedManagerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *FeedManagerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddNewTweetDone() &&
		m.MinimockEditCommentDone() &&
		m.MinimockEditTweetDone() &&
		m.MinimockGiveNewsFeedDone()
}
